<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>蛍光灯 点灯シミュレータ（v7: キーフレーム再生）</title>
<style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: #000;
      color: #e5e5e5;
      font-family: ui-sans-serif, -apple-system, system-ui, "Noto Sans JP", Roboto, Arial, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      display: grid;
      place-items: start center;
      padding: 20px;
    }
    .wrap { 
      width: min(1100px, calc(100vw - 40px)); 
      max-width: 100%;
    }
    h1 { 
      font-size: 20px; 
      margin: 0 0 20px; 
      font-weight: 600; 
      color: #f0f0f0; 
      text-align: center;
    }
    h2 { 
      font-size: 14px; 
      margin: 0 0 12px; 
      color: #eaeaea; 
      font-weight: 600; 
    }
    .panel {
      border: 1px solid #222;
      background: linear-gradient(#0c0c0c, #050505);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 6px 24px rgba(0,0,0,.5), inset 0 1px 0 rgba(255,255,255,.02);
      overflow: hidden;
    }
    .row { 
      display: flex; 
      align-items: center; 
      gap: 12px; 
      flex-wrap: wrap; 
      margin-bottom: 12px;
    }
    .row:last-child {
      margin-bottom: 0;
    }
    label { 
      font-size: 14px; 
      color: #cfcfcf; 
      white-space: nowrap;
    }
    input[type="range"] { 
      width: clamp(200px, 35vw, 400px); 
      accent-color: #9ae6b4; 
    }
    .value { 
      font-variant-numeric: tabular-nums; 
      min-width: 3ch; 
      text-align: right; 
      color: #fff; 
      font-weight: 500;
    }
    canvas { 
      display: block; 
      width: 100%; 
      border-radius: 8px; 
      margin-bottom: 8px;
    }
    canvas:last-child {
      margin-bottom: 0;
    }
    .axis { 
      margin-top: 8px; 
      font-size: 12px; 
      color: #aaa; 
      line-height: 1.4;
    }
    #curve { cursor: default; pointer-events: none; }
    button { 
      background:#1c1c1c; 
      color:#e7e7e7; 
      border:1px solid #333; 
      border-radius:8px; 
      padding:8px 12px; 
      cursor:pointer; 
      font-size: 13px;
      transition: all 0.2s ease;
    }
    button:hover { 
      filter: brightness(1.1); 
      border-color: #555;
    }
    input[type="number"] { 
      width: 6.5em; 
      background:#0d0d0d; 
      color:#eee; 
      border:1px solid #333; 
      border-radius:6px; 
      padding:6px 8px; 
      font-size: 13px;
    }
    input[type="checkbox"] {
      accent-color: #9ae6b4;
      transform: scale(1.1);
    }
</style>
</head>
<body>
  <div class="wrap">
    <h1>蛍光灯 点灯シミュレータ</h1>
    
    <!-- 上部セクション：カラーバー -->
    <div class="panel" style="margin-bottom: 16px;">
      <h2 style="font-size:14px;margin:0 0 12px;color:#eaeaea;font-weight:600">カラーバー</h2>

      <!-- カラーバー（基礎関数の可視化） -->
      <canvas id="bar" height="120" aria-label="カラーバー"></canvas>
      <canvas id="axis" height="36" class="axis" aria-hidden="true"></canvas>
      </div>
      
    <!-- 中央セクション：蛍光灯プレビュー -->
    <div class="panel" style="margin-bottom: 16px;">
      <h2 style="font-size:14px;margin:0 0 12px;color:#eaeaea;font-weight:600">蛍光灯プレビュー</h2>
      <canvas id="lamp" height="140" aria-label="蛍光灯プレビュー"></canvas>
      <canvas id="lampAxis" height="36" class="axis" aria-hidden="true"></canvas>
    </div>

    <!-- 下部セクション：再生シーケンスと色温度カーブ -->
    <div class="panel">
      <!-- 再生 & タイムライン -->
      <h2 style="font-size:14px;margin:0 0 12px;color:#eaeaea;font-weight:600">再生シーケンス</h2>
      
      <!-- 再生制御 -->
      <div class="row" style="gap:10px; margin-bottom:12px">
        <button id="playBtn" title="スペースキーでも再生/停止">▶ 再生</button>
        <button id="genBtn" title="内部でJSONを生成して読み込み">🧪 JSON生成→読込</button>
        <span class="value" id="timeVal">0.00s</span>
        <label for="duration">長さ(s)</label>
        <input id="duration" type="number" min="0.1" step="0.1" value="2.0" />
        <label style="display:flex;align-items:center;gap:6px"><input id="loop" type="checkbox" /> ループ</label>
      </div>
      
      
      
      <canvas id="timeline" height="64" aria-label="タイムライン"></canvas>
      <div class="axis" aria-hidden="true" style="margin-top:6px">再生ヘッドをドラッグで移動 / 空白部クリックで再生ヘッド移動 / 左右矢印キーで0.01秒移動 / シフト+左右矢印キーで0.1秒移動</div>

      <!-- 曲線エディタ（左右対称。編集は左半分のみ） -->
      <h2 style="font-size:14px;margin:24px 0 12px;color:#eaeaea;font-weight:600">色温度カーブ（表示のみ）</h2>
      <canvas id="curve" height="200" aria-label="色温度カーブエディタ"></canvas>
      <div class="axis" aria-hidden="true" style="margin-top:6px">x: 0 → 1（ランプ左→右） / y: 0（暗）→ 1（白）
        ・表示専用。JSONをウィンドウへドラッグ&ドロップで読み込み可能。
        ・常に現在の再生ヘッド位置の色温度カーブを表示（リアルタイム更新）
      </div>
    </div>
    </div>

<script>
    // ===== Math helpers =====
    const clamp = (x, lo, hi) => Math.min(hi, Math.max(lo, x));
    const lerp  = (a, b, t)   => a + (b - a) * t;
    function smoothstep(edge0, edge1, x){
      const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
      return t * t * (3 - 2 * t);
    }

    function deepCopyPoints(arr){ return arr.map(p=>({id:p.id, x:p.x, y:p.y})); }



    // 一貫した左右余白（左=右）
    function getMargins(dpr){
      return { l: Math.floor(42*dpr), r: Math.floor(42*dpr), t: Math.floor(12*dpr), b: Math.floor(24*dpr) };
    }

    // ===== Color Temperature function（指定実装） =====
    function colorTemperature(t) {
      const phase1 = smoothstep(0.0, 0.3, t); // 黒っぽいグレー→暗い赤
      const phase2 = smoothstep(0.3, 0.6, t); // 暗い赤→オレンジ
      const phase3 = smoothstep(0.6, 0.8, t); // オレンジ→黄色
      const phase4 = smoothstep(0.8, 1.0, t); // 黄色→白
      
      // 黒っぽいグレー(30,30,30) → 暗い赤(80,20,20) → オレンジ(255,120,0) → 黄色(255,255,0) → 白(255,255,255)
      const red   = lerp(30, 80, phase1) + lerp(0, 175, phase2) + lerp(0, 0, phase3) + lerp(0, 0, phase4);
      const green = lerp(30, 20, phase1) + lerp(0, 100, phase2) + lerp(0, 135, phase3) + lerp(0, 255, phase4);
      const blue  = lerp(30, 20, phase1) + lerp(0, 0, phase2) + lerp(0, 0, phase3) + lerp(0, 255, phase4);
      
      // アルファ値は常に1.0（透明なし）
      return [red, green, blue, 1.0];
    }

    // ===== Elements =====
    const bar = document.getElementById('bar');
    const axis = document.getElementById('axis');
    const lamp = document.getElementById('lamp');
    const lampAxis = document.getElementById('lampAxis');
    const curve = document.getElementById('curve');
    const timeline = document.getElementById('timeline');

    
    const panel = document.querySelector('.panel');



    const playBtn = document.getElementById('playBtn');
    const genBtn = document.getElementById('genBtn');
    const timeSlider = document.getElementById('timeSlider');
    const timeVal = document.getElementById('timeVal');
    const durationInput = document.getElementById('duration');
    const loopChk = document.getElementById('loop');
    

    // ===== Curve model（左半分のみ：0..0.5 → 0..1） =====
    let points = [ { id: 1, x: 0.0, y: 0.0 }, { id: 2, x: 0.5, y: 0.0 } ];
    let nextPointId = 3;
    function sortPoints(P){ P.sort((a,b)=>a.x-b.x); }

    function evalHalfWithPoints(P, s){
      s = clamp(s, 0, 0.5);
      if (!P || P.length === 0) return 0;
      if (P.length === 1) return clamp(P[0].y, 0, 1);
      const PP = P.map(p=>({x:p.x/0.5, y:p.y})).slice().sort((a,b)=>a.x-b.x);
      const u = (s / 0.5);
      let i = 0; while (i < PP.length - 1 && u > PP[i+1].x) i++; i = Math.max(0, Math.min(i, PP.length - 2));
      const p0 = PP[Math.max(0, i-1)], p1 = PP[i], p2 = PP[i+1], p3 = PP[Math.min(PP.length-1, i+2)];
      const span = (p2.x - p1.x) || 1e-6; const t = (u - p1.x) / span;
      const y0=p0.y,y1=p1.y,y2=p2.y,y3=p3.y;
      const a0 = -0.5*y0 + 1.5*y1 - 1.5*y2 + 0.5*y3;
      const a1 =  y0    - 2.5*y1 + 2.0*y2 - 0.5*y3;
      const a2 = -0.5*y0 + 0.5*y2;
      const a3 =  y1;
      const y = ((a0*t + a1)*t + a2)*t + a3;
      return clamp(y, 0, 1);
    }
    function evalHalf(s){ return evalHalfWithPoints(points, s); }
    function curveYEditor(x){ const s = x <= 0.5 ? x : 1 - x; return evalHalf(s); }

    // LUT（左半分のみ）
    const N_SAMPLES = 256;
    function makeLUT(P){
      const lut = new Float32Array(N_SAMPLES);
      for (let i=0;i<N_SAMPLES;i++){
        const s = (i/(N_SAMPLES-1))*0.5; // 左半分の距離
        lut[i] = evalHalfWithPoints(P, s);
      }
      return lut;
    }
    function sampleLUT(lut, s){ // s: 0..0.5
      const u = clamp(s / 0.5, 0, 1) * (N_SAMPLES-1);
      const i0 = Math.floor(u), i1 = Math.min(N_SAMPLES-1, i0+1);
      const a = u - i0;
      return lerp(lut[i0], lut[i1], a);
    }

    // ===== Timeline / Keyframes =====
    let duration = 2.0; // seconds
    let time = 0.0;
    let playing = false;
    let lastTS = 0;
    let loopPlay = true;

    let keyframes = [];
    let nextKFId = 1;
    let selectedKF = 0; // index
    function initDefaultKeyframes(){
      keyframes = [];
      keyframes.push({ id: nextKFId++, t: 0.0, points: deepCopyPoints(points), lut: makeLUT(points) });
      keyframes.push({ id: nextKFId++, t: duration, points: deepCopyPoints(points), lut: makeLUT(points) });
      selectedKF = 0;
      time = 0; syncTimeUI();
    }

    function sortKeyframes(){ keyframes.sort((a,b)=>a.t-b.t); }

    function findSpan(t){
      sortKeyframes();
      if (t <= keyframes[0].t) return { a: keyframes[0], b: keyframes[0], alpha: 0 };
      if (t >= keyframes[keyframes.length-1].t) return { a: keyframes[keyframes.length-1], b: keyframes[keyframes.length-1], alpha: 0 };
      for (let i=0;i<keyframes.length-1;i++){
        const A = keyframes[i], B = keyframes[i+1];
        if (t >= A.t && t <= B.t){
          const alpha = (t - A.t) / Math.max(1e-6, (B.t - A.t));
          return { a: A, b: B, alpha };
        }
      }
      return { a: keyframes[0], b: keyframes[0], alpha: 0 };
    }

    // 現在の時間位置にキーフレームが存在するかチェック
    function hasKeyframeAtCurrentTime(){
      return keyframes.some(kf => Math.abs(kf.t - time) < 0.001);
    }

    // 現在の時間位置にキーフレームが存在しない場合、自動的に作成
    function ensureKeyframeAtCurrentTime(){
      if (!hasKeyframeAtCurrentTime()) {
        // 現在の再生ヘッドの位置の補完された点の位置からキーフレームを作成
        const currentCurvePoints = getCurrentPlaybackPoints();
        const kf = { 
          id: nextKFId++, 
          t: time, 
          points: deepCopyPoints(currentCurvePoints), 
          lut: makeLUT(currentCurvePoints) 
        };
        keyframes.push(kf); 
        sortKeyframes();
        // 新しく作成されたキーフレームを選択
        const idx = keyframes.findIndex(x=>x.id===kf.id);
        selectedKF = idx;
      }
    }

    // 任意の再生位置の時間補完された点の位置を取得する関数（最適化版）
    function getPlaybackPointsAtTime(targetTime){
      if (keyframes.length === 0) return [];
      if (keyframes.length === 1) return deepCopyPoints(keyframes[0].points);
      
      const { a, b, alpha } = findSpan(targetTime);
      if (a.id === b.id) return deepCopyPoints(a.points);
      
      // 2つのキーフレーム間で制御点を補間
      const result = [];
      const aPoints = a.points;
      const bPoints = b.points;
      
      // より適切な補間処理：曲線の形状を保つ
      if (aPoints.length === 0 && bPoints.length > 0) {
  // aに制御点がない場合でも、現在時刻の曲線からyをサンプリングして返す
  return bPoints.map(p => ({ id: p.id, x: p.x, y: getCurveValueAtTime(targetTime, p.x) }));
}
 else if (aPoints.length > 0 && bPoints.length === 0) {
        // bに制御点がない場合、aの制御点をそのまま使用
        return deepCopyPoints(aPoints);
      } else if (aPoints.length === 0 && bPoints.length === 0) {
        // 両方に制御点がない場合、空の配列を返す
        return [];
      }
      
      // 両方に制御点がある場合、単純な線形補完
      // 制御点の数が異なる場合、すべての制御点を表示
      const allIds = new Set([...aPoints.map(p => p.id), ...bPoints.map(p => p.id)]);
      
      for (const id of allIds) {
        const aPoint = aPoints.find(p => p.id === id);
        const bPoint = bPoints.find(p => p.id === id);
        
        if (aPoint && bPoint) {
          // 両方のキーフレームに存在する場合、線形補完
          result.push({
            id: id,
            x: lerp(aPoint.x, bPoint.x, alpha),
            y: lerp(aPoint.y, bPoint.y, alpha)
          });
        } else if (aPoint) {
                // aのみに存在する場合、現在時刻の曲線からyをサンプリング
      result.push({ id: id, x: aPoint.x, y: getCurveValueAtTime(targetTime, aPoint.x) });
} else if (bPoint) {
                // bのみに存在する場合、現在時刻の曲線からyをサンプリング
      result.push({ id: id, x: bPoint.x, y: getCurveValueAtTime(targetTime, bPoint.x) });
}
      }
      
      sortPoints(result);
      return result;
    }

    // 現在の再生ヘッドの位置の時間補完された点の位置を取得
    function getCurrentPlaybackPoints(){
      return getPlaybackPointsAtTime(time);
    }

    // 時間補完された曲線の値を取得する関数（最適化版）
    function getCurveValueAtTime(targetTime, x){
      const s = x <= 0.5 ? x : 1 - x;
      if (keyframes.length === 0) return 0;
      if (keyframes.length === 1) return sampleLUT(keyframes[0].lut, s);
      
      const { a, b, alpha } = findSpan(targetTime);
      if (a.id === b.id) return sampleLUT(a.lut, s);
      
      const ya = sampleLUT(a.lut, s);
      const yb = sampleLUT(b.lut, s);
      return lerp(ya, yb, alpha);
    }

    // 現在の再生ヘッド位置での曲線の値を取得
    function getCurrentCurveValue(x){
      return getCurveValueAtTime(time, x);
    }

    // 既存の関数を新しい関数を使用するように更新
    function curveYPlayback(x){
      return getCurrentCurveValue(x);
    }

    function updateSelectedKFPointsFromEditor(){
      if (keyframes.length === 0) return;
      // 現在の時間位置にキーフレームが存在しない場合、自動的に作成
      ensureKeyframeAtCurrentTime();
      // 自動作成された場合は、新しく作成されたキーフレームを選択
      if (selectedKF >= keyframes.length) {
        selectedKF = keyframes.length - 1;
      }
      // 選択されたキーフレームを更新（編集された制御点を使用）
      const kf = keyframes[selectedKF];
      kf.points = deepCopyPoints(points);
      kf.lut = makeLUT(points);
    }

    function selectKFByIndex(idx){
      selectedKF = clamp(idx, 0, keyframes.length-1)|0;
      // 編集用 points をキーフレームの状態に同期
      const src = keyframes[selectedKF].points;
      points = deepCopyPoints(src);
      nextPointId = points.reduce((m,p)=>Math.max(m,p.id),0) + 1;
          render();
        }

    // 現在の再生ヘッド位置の制御点を編集用のpointsに反映
    function syncEditorPointsToCurrentTime(){
      if (keyframes.length === 0) return;
      
      // 現在の時間位置にキーフレームが存在する場合
      if (hasKeyframeAtCurrentTime()) {
        const currentKF = keyframes.find(kf => Math.abs(kf.t - time) < 0.001);
        if (currentKF) {
          points = deepCopyPoints(currentKF.points);
          nextPointId = points.reduce((m,p)=>Math.max(m,p.id),0) + 1;
        }
      } else {
        // 現在の時間位置にキーフレームが存在しない場合、補間された制御点を表示
        const currentPoints = getCurrentPlaybackPoints();
        points = deepCopyPoints(currentPoints);
        nextPointId = points.reduce((m,p)=>Math.max(m,p.id),0) + 1;
      }
    }

    function addKeyframeAt(t){
      // 指定された時間位置の補完された点の位置からキーフレームを作成
      const currentCurvePoints = getPlaybackPointsAtTime(t);
      const kf = { 
        id: nextKFId++, 
        t: clamp(t, 0, duration), 
        points: deepCopyPoints(currentCurvePoints), 
        lut: makeLUT(currentCurvePoints) 
      };
      keyframes.push(kf); sortKeyframes();
      const idx = keyframes.findIndex(x=>x.id===kf.id);
      selectKFByIndex(idx);
      time = kf.t; syncTimeUI();
    }

    function deleteSelectedKF(){
      if (keyframes.length <= 2) return; // 2個未満にしない
      const id = keyframes[selectedKF].id;
      keyframes = keyframes.filter(k=>k.id!==id);
      selectKFByIndex(Math.max(0, selectedKF-1));
    }

    // 前のキーフレームを選択（現在の再生ヘッドの位置から見て）
    function selectPreviousKeyframe(){
      if (keyframes.length <= 1) return;
      
      // 現在の再生ヘッドの位置から見て、一つ前のキーフレームを探す
      let prevKF = null;
      for (let i = keyframes.length - 1; i >= 0; i--) {
        if (keyframes[i].t < time) {
          prevKF = keyframes[i];
          break;
        }
      }
      
      // 前のキーフレームが見つからない場合は最後のキーフレーム
      if (!prevKF) {
        prevKF = keyframes[keyframes.length - 1];
      }
      
      // そのキーフレームを選択し、再生ヘッドも移動
      const idx = keyframes.findIndex(kf => kf.id === prevKF.id);
      selectKFByIndex(idx);
      time = prevKF.t;
      syncTimeUI();
      renderCurve(getCssWidth());
    }

    // 次のキーフレームを選択（現在の再生ヘッドの位置から見て）
    function selectNextKeyframe(){
      if (keyframes.length <= 1) return;
      
      // 現在の再生ヘッドの位置から見て、一つ次のキーフレームを探す
      let nextKF = null;
      for (let i = 0; i < keyframes.length; i++) {
        if (keyframes[i].t > time) {
          nextKF = keyframes[i];
          break;
        }
      }
      
      // 次のキーフレームが見つからない場合は最初のキーフレーム
      if (!nextKF) {
        nextKF = keyframes[0];
      }
      
      // そのキーフレームを選択し、再生ヘッドも移動
      const idx = keyframes.findIndex(kf => kf.id === nextKF.id);
      selectKFByIndex(idx);
      time = nextKF.t;
      syncTimeUI();
      renderCurve(getCssWidth());
    }

    // ===== Canvas sizing helpers =====
    function resizeCanvasToCss(canvas, cssW, cssH){
      const dpr = window.devicePixelRatio || 1;
      canvas.width  = Math.max(1, Math.floor(cssW * dpr));
      canvas.height = Math.max(1, Math.floor(cssH * dpr));
      canvas.style.width  = cssW + 'px';
      canvas.style.height = cssH + 'px';
      return dpr;
    }
    function getCssWidth(){ return Math.floor(panel.clientWidth); }

    // ===== Render: bar & axis =====
    function renderBar(cssW){
      const dpr = resizeCanvasToCss(bar, cssW, 120);
      const ctx = bar.getContext('2d');
      const w = bar.width, h = bar.height;
      const img = ctx.createImageData(w, h);
      const data = img.data;
      for (let x = 0; x < w; x++) {
        const t = x / (w - 1);
        const [r0, g0, b0, a0] = colorTemperature(t);
        const r  = Math.round(clamp(r0, 0, 255));
        const g  = Math.round(clamp(g0, 0, 255));
        const bb = Math.round(clamp(b0, 0, 255));
        const a  = Math.round(clamp(a0 * 255, 0, 255));
        for (let y = 0; y < h; y++) {
          const idx = (y * w + x) * 4;
          data[idx+0]=r; data[idx+1]=g; data[idx+2]=bb; data[idx+3]=a;
        }
      }
      ctx.putImageData(img, 0, 0);
    }

    function renderAxis(cssW){
      const dpr = resizeCanvasToCss(axis, cssW, 36);
      const ctx = axis.getContext('2d');
      const wCSS = cssW, hCSS = 36;
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.clearRect(0,0,wCSS,hCSS);
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,wCSS,hCSS);
      ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0.5,0.5); ctx.lineTo((wCSS-1)+0.5, 0.5); ctx.stroke();
      ctx.fillStyle = '#aaa'; ctx.textAlign='center'; ctx.textBaseline='top'; ctx.font='12px ui-sans-serif,system-ui,-apple-system';
      const wMinus1 = wCSS - 1;
      for (let i=0;i<=10;i++){
        const t=i/10; const x=Math.round(t*wMinus1)+0.5; const major=i%2===0;
        ctx.strokeStyle=major?'#777':'#444'; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x, major?12:8); ctx.stroke();
        if(major){ ctx.fillStyle='#cfcfcf'; ctx.fillText(t.toFixed(1), x, 14); }
      }
    }

    // ===== Render: lamp =====
    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
        ctx.beginPath(); 
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y,   x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x,   y+h, rr);
      ctx.arcTo(x,   y+h, x,   y,   rr);
      ctx.arcTo(x,   y,   x+w, y,   rr);
      ctx.closePath();
    }

    function renderLamp(cssW){
      const dpr = resizeCanvasToCss(lamp, cssW, 140);
      const ctx = lamp.getContext('2d');
      const w = lamp.width, h = lamp.height;
      ctx.clearRect(0,0,w,h);

      ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);

      const M = getMargins(dpr);
      const rx = M.l, ry = Math.floor(14*dpr);
      const rw = w - M.l - M.r; const rh = h - ry*2;

      // 固定サイズで蛍光灯を描画
      const adjustedWidth = rw;
      const adjustedHeight = rh;
      const adjustedX = rx;
      const adjustedY = ry;

      // オフスクリーンで描画
      const off = document.createElement('canvas');
      off.width = adjustedWidth; off.height = adjustedHeight;
      const octx = off.getContext('2d');
      const inner = octx.createImageData(adjustedWidth, adjustedHeight);
      const data = inner.data;

      for (let x = 0; x < adjustedWidth; x++) {
        const xNorm = x / (adjustedWidth - 1); // 0..1 左→右
        // 時間補完された値を使用（再生中でなくても）
        const tt = getCurrentCurveValue(xNorm);
        const [r0,g0,b0,a0] = colorTemperature(tt);
        const r = Math.round(clamp(r0, 0, 255));
        const g = Math.round(clamp(g0, 0, 255));
        const b = Math.round(clamp(b0, 0, 255));
        const a = Math.round(clamp(a0 * 255, 0, 255));
        for (let y = 0; y < adjustedHeight; y++){
          const idx = (y * adjustedWidth + x) * 4;
          data[idx+0]=r; data[idx+1]=g; data[idx+2]=b; data[idx+3]=a;
        }
      }
      octx.putImageData(inner, 0, 0);

      // 角丸＆枠線なし
      ctx.save();
      roundRect(ctx, adjustedX, adjustedY, adjustedWidth, adjustedHeight, Math.floor(10*dpr));
      ctx.clip();
      ctx.drawImage(off, adjustedX, adjustedY);
      ctx.restore();
    }

    function renderLampAxis(cssW){
      const dpr = resizeCanvasToCss(lampAxis, cssW, 36);
      const ctx = lampAxis.getContext('2d');
      const wCSS = cssW, hCSS = 36;
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.clearRect(0,0,wCSS,hCSS);
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,wCSS,hCSS);
      const M = getMargins(dpr);
      
      // 固定サイズで軸を描画
      const rw = wCSS - M.l - M.r;
      const adjustedWidth = rw;
      const adjustedX = M.l;
      
      ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(adjustedX+0.5, 0); ctx.lineTo(adjustedX+0.5, hCSS); ctx.stroke();
      ctx.beginPath(); ctx.moveTo((adjustedX+adjustedWidth)-0.5, 0); ctx.lineTo((adjustedX+adjustedWidth)-0.5, hCSS); ctx.stroke();
      
      const innerW = adjustedWidth; const x0 = adjustedX;
      ctx.strokeStyle = '#333'; ctx.beginPath(); ctx.moveTo(0.5, 0.5); ctx.lineTo(wCSS-0.5, 0.5); ctx.stroke();
      ctx.fillStyle = '#aaa'; ctx.textAlign='center'; ctx.textBaseline='top'; ctx.font='12px ui-sans-serif,system-ui,-apple-system';
      for (let i=0;i<=10;i++){
        const t = i/10; const x = Math.round(x0 + t*(innerW-1)) + 0.5; const major=i%2===0;
        ctx.strokeStyle=major?'#777':'#444'; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x, major?12:8); ctx.stroke();
        if(major){ ctx.fillStyle='#cfcfcf'; ctx.fillText(t.toFixed(1), x, 14); }
      }
    }

    // ===== Render: curve editor =====
    const CURVE_H_CSS = 200;
    function renderCurve(cssW){
      const dpr = resizeCanvasToCss(curve, cssW, CURVE_H_CSS);
      const ctx = curve.getContext('2d');
      const w = curve.width, h = curve.height;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,w,h);

      const M = getMargins(dpr);
      const gx = M.l, gy = M.t, gw = w - M.l - M.r, gh = h - M.t - M.b;

      ctx.fillStyle = '#0b0b0b'; ctx.fillRect(0,0,w,h);
      ctx.fillStyle = '#111'; ctx.fillRect(gx, gy, gw, gh);

      // グリッド
      ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
      for (let i=0;i<=10;i++){
        const xx = gx + Math.round((i/10)* (gw-1)) + 0.5;
        const yy = gy + Math.round((i/10)* (gh-1)) + 0.5;
        ctx.beginPath(); ctx.moveTo(xx, gy); ctx.lineTo(xx, gy+gh); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(gx, yy); ctx.lineTo(gx+gw, yy); ctx.stroke();
      }
      // 中央線 0.5
      ctx.strokeStyle = '#333';
      const cxLine = gx + Math.round(0.5*(gw-1)) + 0.5;
      ctx.beginPath(); ctx.moveTo(cxLine, gy); ctx.lineTo(cxLine, gy+gh); ctx.stroke();

      // 軸ラベル
      ctx.fillStyle = '#aaa'; ctx.font = Math.floor(12*dpr)+'px ui-sans-serif,system-ui,-apple-system'; ctx.textAlign='center'; ctx.textBaseline='top';
      for (let i=0;i<=10;i+=2){
        const xx = gx + Math.round((i/10)*(gw-1));
        ctx.fillText((i/10).toFixed(1), xx, gy+gh+Math.floor(6*dpr));
      }
      ctx.save();
      ctx.translate(Math.floor(18*dpr), gy+gh/2);
      ctx.rotate(-Math.PI/2);
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('色温度 (0..1)', 0, 0);
      ctx.restore();

            // 曲線サンプル線（常に現在の再生ヘッド位置の色温度カーブを表示）
      ctx.save();
      ctx.beginPath();
      ctx.rect(gx, gy, gw, gh);
      ctx.clip();
      ctx.lineWidth = Math.max(1, Math.floor(2*dpr));
      ctx.strokeStyle = '#6ee7b7';
      
      let first = true;
      for (let i=0;i<gw;i++){
        const xNorm = i/(gw-1);
        // 新しい時間補完関数を使用
        const y = getCurrentCurveValue(xNorm);
        const px = gx + i + 0.5;
        const py = gy + (1 - y)*(gh-1) + 0.5;
        if(first){ ctx.beginPath(); ctx.moveTo(px, py); first=false; }
        else { ctx.lineTo(px, py); }
      }
      ctx.stroke();
      ctx.restore();

      // 制御点（左半分）とミラー点（右半分）
      // 曲線と同じ計算方法で制御点の位置を表示
      const currentPoints = getCurrentPlaybackPoints();
      
      for (const p of currentPoints){
        // 制御点のx座標での曲線の値を計算（曲線と同じ計算方法）
        const curveY = getCurrentCurveValue(p.x);
        
        const xL = gx + Math.round(p.x*(gw-1)) + 0.5;
        const yM = gy + Math.round((1 - curveY)*(gh-1)) + 0.5;
        // 左（編集可能）
        ctx.fillStyle = '#e5fff5';
        ctx.strokeStyle = '#1f8a5a';
        ctx.lineWidth = Math.max(1, Math.floor(2*dpr));
        ctx.beginPath(); ctx.arc(xL, yM, Math.max(3, Math.floor(5*dpr)), 0, Math.PI*2); ctx.fill(); ctx.stroke();
        // 右（ミラー表示）
        const xR = gx + Math.round((1 - p.x)*(gw-1)) + 0.5;
        ctx.strokeStyle = '#63b3a7';
        ctx.fillStyle = 'rgba(229,255,245,0.25)';
        ctx.beginPath(); ctx.arc(xR, yM, Math.max(3, Math.floor(5*dpr)), 0, Math.PI*2); ctx.fill(); ctx.stroke();
      }

      ctx.strokeStyle = '#2a2a2a'; ctx.lineWidth = Math.max(1, Math.floor(1*dpr));
      ctx.strokeRect(gx, gy, gw, gh);

      curve._layout = { dpr, gx, gy, gw, gh };
    }

    // ===== Render: timeline =====
    function renderTimeline(cssW){
      const dpr = resizeCanvasToCss(timeline, cssW, 64);
      const ctx = timeline.getContext('2d');
      const w = timeline.width, h = timeline.height;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,w,h);

      const M = getMargins(dpr);
      const gx = M.l, gy = Math.floor(10*dpr), gw = w - M.l - M.r, gh = h - gy - Math.floor(10*dpr);

      ctx.fillStyle = '#0b0b0b'; ctx.fillRect(0,0,w,h);
      ctx.fillStyle = '#111'; ctx.fillRect(gx, gy, gw, gh);

      // セコンド目盛
      const secStep = Math.max(0.1, Math.pow(10, Math.floor(Math.log10(duration)) - 1));
      ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
      for (let t=0; t<=duration+1e-6; t+=secStep){
        const tn = t/duration; const x = gx + Math.round(tn*(gw-1)) + 0.5;
        ctx.beginPath(); ctx.moveTo(x, gy); ctx.lineTo(x, gy+gh); ctx.stroke();
      }

      // プレイヘッド
      const tn = clamp(time/duration, 0, 1); const xPH = gx + Math.round(tn*(gw-1)) + 0.5;
      ctx.strokeStyle = '#e6e6e6'; ctx.lineWidth = Math.max(1, Math.floor(2*dpr));
      ctx.beginPath(); ctx.moveTo(xPH, gy-4); ctx.lineTo(xPH, gy+gh+4); ctx.stroke();

      // キーフレーム（ダイヤ）
      sortKeyframes();
      for (let i=0;i<keyframes.length;i++){
        const kf = keyframes[i];
        const x = gx + Math.round((kf.t/duration)*(gw-1)) + 0.5;
        const r = Math.max(4, Math.floor(6*dpr));
        ctx.save();
        ctx.translate(x, gy + gh/2);
        ctx.rotate(Math.PI/4);
        ctx.fillStyle = (i===selectedKF)?'#8ff0c6':'#cfe9de';
        ctx.strokeStyle = (i===selectedKF)?'#1f8a5a':'#4a7a6e';
        ctx.lineWidth = Math.max(1, Math.floor(2*dpr));
        ctx.beginPath();
        ctx.rect(-r, -r, 2*r, 2*r);
        ctx.fill(); ctx.stroke();
        ctx.restore();
      }
      
      // 選択されていない場合の表示
      if (selectedKF === -1) {
        ctx.fillStyle = '#666';
        ctx.font = Math.floor(10*dpr)+'px ui-sans-serif,system-ui,-apple-system';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('キーフレーム未選択', gx + gw/2, gy + gh + 4);
      }

      // ラベル
      ctx.fillStyle = '#aaa'; ctx.font = Math.floor(12*dpr)+'px ui-sans-serif,system-ui,-apple-system';
      ctx.textAlign='left'; ctx.textBaseline='top';
      ctx.fillText(`duration ${duration.toFixed(2)}s  / time ${time.toFixed(2)}s`, gx, 2);

      timeline._layout = { dpr, gx, gy, gw, gh };
    }

    function render(){
      const cssW = getCssWidth();
      renderBar(cssW);
      renderAxis(cssW);
      renderLamp(cssW);
      renderLampAxis(cssW);
      renderCurve(cssW);
      renderTimeline(cssW);
    }

    // ===== Audio: flash.wav trigger on threshold =====
    let audioCtx = null;
    let flashBuffer = null;
    let audioLoaded = false;
    let htmlAudio = null; // fallback element
    let audioInitialized = false;
    // Hum (buzz) nodes
    let humGain = null;
    let humOsc1 = null;
    let humOsc2 = null;
    let humLfo = null;
    let humLfoGain = null;
    let isHumRunning = false;
    const HUM_BASE_GAIN = 0.025; // 最大時の基準ゲイン
    let humAvgEma = 0.0;         // 色温度の指数移動平均
    const HUM_EMA_ALPHA = 0.2;   // 応答係数（0..1）
    async function ensureAudio(){
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') await audioCtx.resume();
        if (!audioLoaded){
          const isFile = location.protocol === 'file:';
          if (!isFile){
            try {
              const res = await fetch('flash.wav');
              if (!res.ok) throw new Error('fetch failed');
              const arr = await res.arrayBuffer();
              flashBuffer = await audioCtx.decodeAudioData(arr);
              audioLoaded = true;
            } catch {}
          }
          if (!audioLoaded){
            // Fallback: HTMLAudioElement
            if (!htmlAudio){
              htmlAudio = new Audio('flash.wav');
              htmlAudio.preload = 'auto';
            }
          }
        }
      } catch {}
    }
    function playFlash(){
      // pick a wider random range and random start offset
      const rate = 0.9 + Math.random()*0.20; // 0.85x..1.15x
      const offset = Math.random() * 0.02;    // up to 20ms offset
      // Prefer WebAudio if buffer available
      if (audioCtx && flashBuffer){
        const src = audioCtx.createBufferSource();
        src.buffer = flashBuffer;
        // use both detune (cents) and playbackRate for broader device support
        if (typeof src.detune === 'object' || typeof src.detune === 'number'){
          try { src.detune.value = (Math.random()*200 - 100); } catch {}
        }
        try { src.playbackRate.value = rate; } catch {}
        src.connect(audioCtx.destination);
        try { src.start(0, offset); } catch {}
        return;
      }
      // Fallback: HTMLAudioElement (clone to allow overlap)
      if (htmlAudio){
        try {
          const a = htmlAudio.cloneNode(true);
          // ensure pitch follows playbackRate on all browsers
          try { a.preservesPitch = false; } catch {}
          try { a.mozPreservesPitch = false; } catch {}
          try { a.webkitPreservesPitch = false; } catch {}
          a.playbackRate = rate;
          // apply small start offset when possible
          try { a.currentTime = offset; } catch {}
          a.play().catch(()=>{});
        } catch {}
      }
    }
    let wasAboveFlash = false;
    function computeMaxCurveValue(){
      let maxY = 0;
      const S = 32;
      for (let i=0;i<S;i++){
        const x = i/(S-1);
        const y = getCurrentCurveValue(x);
        if (y > maxY) maxY = y;
      }
      return maxY;
    }
    function computeAvgCurveValue(){
      let sumY = 0;
      const S = 32;
      for (let i=0;i<S;i++){
        const x = i/(S-1);
        sumY += getCurrentCurveValue(x);
      }
      return sumY / S;
    }
    function updateHumDynamics(){
      if (!audioCtx || !humGain) return;
      const avg = computeAvgCurveValue();
      humAvgEma = HUM_EMA_ALPHA * avg + (1 - HUM_EMA_ALPHA) * humAvgEma;
      const target = Math.max(0, Math.min(1, 1 - humAvgEma)) * HUM_BASE_GAIN;
      try { humGain.gain.setTargetAtTime(target, audioCtx.currentTime, 0.05); } catch {}
    }
    async function checkFlash(){
      const maxY = computeMaxCurveValue();
      const above = maxY > 0.7;
      if (!wasAboveFlash && above){
        await ensureAudio();
        playFlash();
      }
      wasAboveFlash = above;
    }

    // Continuous hum while playing
    async function startHum(){
      await ensureAudio();
      if (!audioCtx) return;
      if (isHumRunning) return;
      humGain = audioCtx.createGain();
      humGain.gain.value = HUM_BASE_GAIN; // 初期値
      humGain.connect(audioCtx.destination);
      // base hum: 100 Hz sine + 200 Hz sine (subtle)
      humOsc1 = audioCtx.createOscillator();
      humOsc1.type = 'sine';
      humOsc1.frequency.value = 100;
      humOsc1.connect(humGain);
      humOsc2 = audioCtx.createOscillator();
      humOsc2.type = 'sine';
      humOsc2.frequency.value = 200;
      humOsc2.connect(humGain);
      try { humOsc1.start(); } catch {}
      try { humOsc2.start(); } catch {}
      isHumRunning = true;
    }
    function stopHum(){
      if (!audioCtx) return;
      if (!isHumRunning) return;
      // fade out
      try {
        const now = audioCtx.currentTime;
        humGain.gain.setTargetAtTime(0.0, now, 0.15);
      } catch {}
      const toStop = [humOsc1, humOsc2];
      setTimeout(()=>{
        for (const n of toStop){ try { n && n.stop(); } catch {} }
        humOsc1 = humOsc2 = null;
        if (humGain){ try { humGain.disconnect(); } catch {} humGain = null; }
        if (humLfoGain){ try { humLfoGain.disconnect(); } catch {} humLfoGain = null; }
        isHumRunning = false;
      }, 400);
    }

    // Initialize audio on first user gesture to satisfy autoplay policies
    function initAudioOnGesture(){
      if (audioInitialized) return;
      audioInitialized = true;
      ensureAudio();
    }
    window.addEventListener('pointerdown', initAudioOnGesture, { once: true });
    window.addEventListener('keydown', (e)=>{ if (e.code === 'Space' || e.key === 'Enter') initAudioOnGesture(); }, { once: true });

    // ===== Time controls =====
    function syncTimeUI(){
      time = clamp(time, 0, duration);
      timeVal.textContent = `${time.toFixed(2)}s`;
      // 再生ヘッドが移動した時に編集用の制御点も同期
      syncEditorPointsToCurrentTime();
      renderLamp(getCssWidth());
      renderTimeline(getCssWidth());
      checkFlash();
      updateHumDynamics();
    }
    durationInput.addEventListener('change', ()=>{
      duration = Math.max(0.1, Number(durationInput.value));
      // 範囲外のキーフレームは内側にクランプ
      for (const kf of keyframes){ kf.t = clamp(kf.t, 0, duration); }
      sortKeyframes();
      if (time > duration) time = duration;
      syncTimeUI();
    });
    loopChk.addEventListener('change', ()=>{ loopPlay = !!loopChk.checked; });

    // Play/Pause
    function tick(ts){
      if (!playing){ lastTS = ts; return; }
      const dt = (ts - lastTS) / 1000; lastTS = ts;
      time += dt;
      if (time > duration){
        if (loopPlay){ 
          time = time % duration; 
        } else { 
          time = duration; 
          setPlaying(false); 
        }
      }
      syncTimeUI();
      // 再生中は色温度カーブもリアルタイム更新
      renderCurve(getCssWidth());
      requestAnimationFrame(tick);
    }
    function setPlaying(v){
      playing = v; playBtn.textContent = v ? '⏸ 停止' : '▶ 再生';
      if (v) {
        // 再生開始時にキーフレームの選択を解除
        selectedKF = -1;
        // 最後の状態で再生開始する場合は最初に戻る
        if (time >= duration) {
          time = 0;
        }
        // ensure audio and start hum while playing
        startHum();
        requestAnimationFrame((ts)=>{ lastTS = ts; requestAnimationFrame(tick); });
      } else {
        // stop hum when paused
        stopHum();
      }
    }
    playBtn.addEventListener('click', ()=> setPlaying(!playing));
    window.addEventListener('keydown', (e)=>{
      if (e.code === 'Space') {
        e.preventDefault();
        setPlaying(!playing);
      } else if (e.code === 'ArrowLeft') {
        e.preventDefault();
        const step = e.shiftKey ? 0.1 : 0.01;
        time = clamp(time - step, 0, duration);
        syncTimeUI();
        // 編集用の制御点を現在の時間位置に同期
        syncEditorPointsToCurrentTime();
        renderCurve(getCssWidth());
      } else if (e.code === 'ArrowRight') {
        e.preventDefault();
        const step = e.shiftKey ? 0.1 : 0.01;
        time = clamp(time + step, 0, duration);
        syncTimeUI();
        // 編集用の制御点を現在の時間位置に同期
        syncEditorPointsToCurrentTime();
        renderCurve(getCssWidth());
      }
    });

    // ===== Timeline interactions =====
    let dragKF = null; // { idx, startX, moved, origT }
    let dragPlayhead = null; // { startX, moved, isDragging }
    function tToX(t){ const L=timeline._layout; const {gx,gw}=L; return gx + Math.round((t/duration)*(gw-1)) + 0.5; }
    function xToT(xCSS){ const L=timeline._layout; const {dpr,gx,gw}=L; const xd=xCSS*dpr; const tn=clamp((xd-gx)/(gw-1),0,1); return tn*duration; }

    function hitTestKF(xCSS, yCSS){ return -1; }

    // 再生ヘッドのヒットテスト
    function hitTestPlayhead(xCSS, yCSS){
      const L = timeline._layout; if(!L) return false; const {dpr, gy, gh} = L;
      const cx = xCSS * dpr, cy = yCSS * dpr;
      const playheadX = tToX(time);
      const dx = playheadX - cx, dy = (gy + gh/2) - cy;
      const d2 = dx*dx + dy*dy;
      return d2 < Math.pow(15*dpr,2); // 再生ヘッドのヒット範囲
    }

    // グローバルなポインターイベントハンドラー
    function handleGlobalPointerMove(e) {
      if (dragPlayhead && dragPlayhead.isDragging) {
        const rect = timeline.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // タイムラインの範囲内かチェック
        if (x >= 0 && x <= rect.width && y >= 0 && y <= rect.height) {
          const t = xToT(x);
          time = clamp(t, 0, duration);
          // ドラッグ中もリアルタイムで更新
          syncTimeUI();
          // 編集用の制御点を現在の時間位置に同期
          syncEditorPointsToCurrentTime();
          renderCurve(getCssWidth());
        } else {
          // 範囲外でも適切に時間を更新（境界値にクランプ）
          let t;
          if (x < 0) {
            t = 0; // 左端
          } else if (x > rect.width) {
            t = duration; // 右端
          } else {
            t = xToT(x);
          }
          time = clamp(t, 0, duration);
          // ドラッグ中もリアルタイムで更新
          syncTimeUI();
          // 編集用の制御点を現在の時間位置に同期
          syncEditorPointsToCurrentTime();
          renderCurve(getCssWidth());
        }
      }
    }

    function handleGlobalPointerUp(e) {
      if (dragPlayhead && dragPlayhead.isDragging) {
        dragPlayhead.isDragging = false;
        dragPlayhead = null;
        timeline.style.cursor = 'crosshair';
        renderTimeline(getCssWidth());
        
        // ポインターキャプチャを解除
        try {
          timeline.releasePointerCapture(e.pointerId);
        } catch (err) {
          // ポインターキャプチャが設定されていない場合のエラーを無視
        }
        
        // グローバルイベントリスナーを削除
        document.removeEventListener('pointermove', handleGlobalPointerMove);
        document.removeEventListener('pointerup', handleGlobalPointerUp);
      }
    }

    timeline.addEventListener('pointerdown', (e)=>{
      const rect = timeline.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const idx = hitTestKF(x, y);
      
      if (hitTestPlayhead(x, y)) {
        // 再生ヘッドをドラッグ開始
        dragPlayhead = { startX: x, moved: false, isDragging: true };
        timeline.style.cursor = 'grabbing';
        // ポインターキャプチャを設定
        timeline.setPointerCapture(e.pointerId);
        // グローバルイベントリスナーを追加
        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);
      } else {
        // 空所クリックで再生ヘッドを移動し、ドラッグ開始
        const t = xToT(x);
        time = t;
        syncTimeUI();
        // 編集用の制御点を現在の時間位置に同期
        syncEditorPointsToCurrentTime();
        renderCurve(getCssWidth());
        
        // 空所クリックでも再生ヘッドドラッグを開始
        dragPlayhead = { startX: x, moved: false, isDragging: true };
        timeline.style.cursor = 'grabbing';
        // ポインターキャプチャを設定
        timeline.setPointerCapture(e.pointerId);
        // グローバルイベントリスナーを追加
        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);
      }
    });
    
    timeline.addEventListener('pointermove', (e)=>{
      if (!timeline._layout) return;
      const rect = timeline.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      
      // カーソルスタイルの更新（ドラッグ中でない場合のみ）
      if (!dragPlayhead || !dragPlayhead.isDragging) {
        if (hitTestKF(x,y) >= 0) {
          timeline.style.cursor = 'grab';
        } else if (hitTestPlayhead(x, y)) {
          timeline.style.cursor = 'grab';
        } else {
          timeline.style.cursor = 'crosshair';
        }
      }
      
      // キーフレームのドラッグ処理は無効化
      
      // 再生ヘッドのドラッグ処理（タイムライン内でのみ）
      if (dragPlayhead && dragPlayhead.isDragging) {
        dragPlayhead.moved = dragPlayhead.moved || (Math.abs(x - dragPlayhead.startX) > 2);
        const t = xToT(x);
        time = clamp(t, 0, duration);
        // ドラッグ中もリアルタイムで更新
        syncTimeUI();
        // 編集用の制御点を現在の時間位置に同期
        syncEditorPointsToCurrentTime();
        renderCurve(getCssWidth());
      }
    });
    
    timeline.addEventListener('pointerup', (e)=>{});

    // Buttons for KF
    

    // ===== Curve editor interactions =====
    let drag = null; // { id, startX, startY, moved }

    function hitTestPoint(xCSS, yCSS){
      const L = curve._layout; if(!L) return null;
      const { dpr, gx, gy, gw, gh } = L;
      const r = Math.max(6, Math.floor(9*dpr));
      const cx = xCSS * dpr, cy = yCSS * dpr;
      let found = null, best = 1e9;
      for (const p of points){
        const leftX  = gx + Math.round(p.x*(gw-1)) + 0.5;
        const rightX = gx + Math.round((1 - p.x)*(gw-1)) + 0.5;
        const curveY = getCurrentCurveValue(p.x);
        const yM    = gy + Math.round((1 - curveY)*(gh-1)) + 0.5;
        let dx = leftX - cx, dy = yM - cy; let d2 = dx*dx + dy*dy;
        if (d2 < r*r && d2 < best){ best = d2; found = { id: p.id }; }
        dx = rightX - cx; dy = yM - cy; d2 = dx*dx + dy*dy;
        if (d2 < r*r && d2 < best){ best = d2; found = { id: p.id }; }
      }
      return found;
    }

    function cssToNorm(xCSS, yCSS){
      const L = curve._layout; if(!L) return {x:0,y:0};
      const { dpr, gx, gy, gw, gh } = L;
      const xd = xCSS * dpr, yd = yCSS * dpr;
      const x = clamp((xd - gx) / (gw - 1), 0, 1);
      const y = clamp(1 - (yd - gy) / (gh - 1), 0, 1);
      return {x, y};
    }

    curve.addEventListener('pointerdown', (e)=>{
      curve.setPointerCapture(e.pointerId);
      const rect = curve.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const target = hitTestPoint(x, y);
      if (target){
        drag = { id: target.id, startX: x, startY: y, moved: false };
        curve.style.cursor = 'grabbing';
  } else {
        // 空所クリック: 点を即時作成し、ドラッグ対象にする
        const {x: xn, y: yn} = cssToNorm(x, y);
        const s = xn <= 0.5 ? xn : 1 - xn;
        const newPoint = { id: nextPointId++, x: clamp(s, 0, 0.5), y: yn };
        points.push(newPoint);
        sortPoints(points);
        updateSelectedKFPointsFromEditor();
        drag = { id: newPoint.id, startX: x, startY: y, moved: false };
        curve.style.cursor = 'grabbing';
        render();
      }
    });

    curve.addEventListener('pointermove', (e)=>{
      const rect = curve.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;

      if (!drag){
        curve.style.cursor = hitTestPoint(x, y) ? 'grab' : 'crosshair';
        return;
      }

      const moved = drag.moved || (Math.hypot(x - drag.startX, y - drag.startY) > 3);
      drag.moved = moved;

      if (drag.id){
        const p = points.find(pp=>pp.id===drag.id);
        if (p){
          const {x: xn, y: yn} = cssToNorm(x, y);
          const s = xn <= 0.5 ? xn : 1 - xn; // 左半分へ折り返し
          const newX = clamp(s, 0, 0.5);
          const newY = yn;
          if (newX !== p.x || newY !== p.y){
            p.x = newX;
            p.y = newY;
            sortPoints(points);
            updateSelectedKFPointsFromEditor();
            render();
          }
        }
      }
    });

    curve.addEventListener('pointerup', (e)=>{
      const rect = curve.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      if (!drag){ return; }

      // pointerdownで必要に応じて作成済みのため、ここでは追加・削除のいずれも行わない
       drag = null; curve.style.cursor = 'crosshair';
    });

    
    // ===== Preset & IO helpers =====
    function makePoints(y0, y1, y2, y3){
      // Consistent IDs so interpolation is stable across KFs
      return [
        { id: 101, x: 0.02, y: y0 },
        { id: 102, x: 0.12, y: y1 },
        { id: 103, x: 0.25, y: y2 },
        { id: 104, x: 0.50, y: y3 },
      ];
    }
    function shapeOff(){ return makePoints(0.0, 0.0, 0.0, 0.0); }
    function shapeEndsGlow(s){ // s: 0..1 strength
      const e = Math.min(1, Math.max(0, s));
      // ends high, center low
      return makePoints(0.55*e, 0.35*e + 0.05, 0.15*e + 0.03, 0.06*e + 0.02);
    }
    function shapeFlash(){ return makePoints(0.95, 0.95, 0.92, 0.88); }
    function shapeRamp(a){ // a: 0..1 progress toward white
      const k = Math.min(1, Math.max(0, a));
      // gently lift whole tube; keep ends slightly ahead of center
      return makePoints(0.8 + 0.2*k, 0.65 + 0.35*k, 0.5 + 0.5*k, 0.38 + 0.62*k);
    }
    function shapeWhite(){ return makePoints(1.0, 1.0, 1.0, 1.0); }

    function setKeyframesFromSpec(spec, setDuration){
      if (setDuration) {
        duration = setDuration;
        durationInput.value = String(setDuration.toFixed(2));
      }
      keyframes = [];
      nextKFId = 1;
      for (const {t, pts} of spec){
        const P = deepCopyPoints(pts);
        keyframes.push({ id: nextKFId++, t, points: P, lut: makeLUT(P) });
      }
      sortKeyframes();
      selectedKF = 0;
      // Sync editor "points" to selected
      points = deepCopyPoints(keyframes[0].points);
      nextPointId = points.reduce((m,p)=>Math.max(m,p.id),0) + 1;
      time = 0;
      syncTimeUI();
      render();
    }

    function presetThreeTriesThenStable(){
      const D = duration; // use current duration
      
      // 最初の溜めを大きく取り、残りを1.0~2.0秒に圧縮
      const rampStart = Math.max(1.0, D - 2.0); // 残り2秒以内で開始
      const rampDuration = Math.min(2.0, D - rampStart); // 実際の圧縮時間
      
      // 時間配分を調整
      const spec = [
        { t: 0.00, pts: shapeOff() },

        // Attempt 1 (圧縮時間内) - 鋭い点滅
        { t: rampStart + rampDuration * 0.1, pts: shapeEndsGlow(0.8) },
        { t: rampStart + rampDuration * 0.12, pts: shapeFlash() },
        { t: rampStart + rampDuration * 0.14, pts: shapeOff() },

        // Attempt 2 (圧縮時間内) - 鋭い点滅
        { t: rampStart + rampDuration * 0.35, pts: shapeEndsGlow(0.9) },
        { t: rampStart + rampDuration * 0.37, pts: shapeFlash() },
        { t: rampStart + rampDuration * 0.39, pts: shapeOff() },

        // Attempt 3 (圧縮時間内) - 鋭い点滅
        { t: rampStart + rampDuration * 0.6, pts: shapeEndsGlow(1.0) },
        { t: rampStart + rampDuration * 0.62, pts: shapeFlash() },
        { t: rampStart + rampDuration * 0.64, pts: shapeEndsGlow(1.0) },

        // 両端が白く光り、その後全体がパッと白くなる
        { t: rampStart + rampDuration * 0.8, pts: shapeEndsGlow(1.0) }, // 両端が白く光る
        { t: rampStart + rampDuration * 0.85, pts: shapeEndsGlow(1.0) }, // 少し溜め
        { t: rampStart + rampDuration * 0.9, pts: shapeWhite() }, // 全体がパッと白くなる
        { t: D, pts: shapeWhite() }, // 最終状態
      ];
      setKeyframesFromSpec(spec);
    }

    function resetKeyframes(){
      initDefaultKeyframes();
      // Reset edit points to the first KF
      points = deepCopyPoints(keyframes[0].points);
      nextPointId = points.reduce((m,p)=>Math.max(m,p.id),0) + 1;
      time = 0;
      syncTimeUI();
      render();
    }

    function exportJSON(){
      const payload = {
        version: 1,
        duration,
        keyframes: keyframes.map(k => ({ t: k.t, points: k.points })),
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], {type: "application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "fluorescent_timeline.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    }

    // ===== 内部JSON生成器 =====
    function mulberry32(seed){
      let t = seed >>> 0;
      return function(){
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }
    function clamp01(v){ return Math.max(0, Math.min(1, v)); }
    
    // ガウス分布（正規分布）の乱数生成（Box-Muller変換）
    function gaussianRandom(mean, stdDev, rndFunc){
      let u1, u2;
      do {
        u1 = rndFunc();
        u2 = rndFunc();
      } while (u1 === 0); // u1が0の場合は再生成
      
      // Box-Muller変換
      const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
      return mean + z0 * stdDev;
    }
    
    // ガウス分布で範囲制限された乱数生成
    function gaussianRange(mean, stdDev, min, max, rndFunc){
      let result;
      do {
        result = gaussianRandom(mean, stdDev, rndFunc);
      } while (result < min || result > max);
      return result;
    }
    function generateFluorescentTimeline({
      version = 1,
      duration = 2.0,
      controlPoints,
      seed = 42,
      params = {}
    }){
      const rnd = mulberry32(seed);
      const p = {
        baseGain: 0.85,
        spread: 0.20,
        gainPow: 1.25,
        midRange: [0.25, 0.65],
        peakRange: [0.95, 1.0],
        zeroRange: [0.00, 0.06],
        dtRangeMs: [50, 85],
        decayRate: 0.018,
        noise: 0.015,
        // startTime を相対レンジでランダム化（durationに比例）
        startTimeRangeRel: [0.45, 0.65], // 例: duration=2s → 0.90s〜1.30s（未使用時のフォールバック）
        // 絶対時間での開始レンジ（優先）
        startTimeAbsRange: [0.96, 1.06], // 1パルス目は1.0秒付近から
        // 追加の全体ランダム性
        globalJitterMs: 10,      // 各イベントの微小ジッタ
        // 全体構成のランダム性
        // 1パルス目までの時間をランダム化
        firstPulseDelayRange: [0.85, 1.15], // 1パルス目開始時刻の範囲
        // 安定までの時間をランダム化
        settleTimeRangeRel: [0.15, 0.35], // durationに対する比率
        // 安定までのパルス回数をランダム化
        pulseCountRange: [3, 8], // 安定までのパルス数
        // 安定後の時間を確保
        stableTimeAfterSettle: 0.5, // 安定後の時間（秒）
        // パルス間隔のランダム性強化（ガウス分布）
        pulseIntervalRange: [40, 120], // パルス間隔（ms）
        pulseIntervalStdDev: 35,       // パルス間隔の標準偏差（ms）- 分散を大きく
        burstIntervalRange: [80, 180], // バースト間隔（ms）
        burstIntervalStdDev: 50,       // バースト間隔の標準偏差（ms）- 分散を大きく
        // パルス形状（鋭い立ち上がり→短いピーク→即減衰）
        pulseRiseMsRange: [8, 12],   // 立ち上がり（ランダム性抑制）
        pulseHoldMsRange: [2, 4],    // ごく短いホールド（ランダム性抑制）
        pulseFallMsRange: [35, 45],  // 減衰（ランダム性抑制）
        pulseInterGapMsRange: [24, 70], // パルス間ギャップ
        pulsesPerBurstRange: [1, 3], // 1塊のパルス数
        burstGapMsRange: [60, 140],  // 次の塊まで
        settleBufferMs: 100,
        useSampleIdProfiles: true,
        // レア長溜め（極稀に長い待機を挿入）
        rareLongTameProb: 0.06,             // 6% で長溜めを発生
        rareLongTameMsRange: [600, 1800]    // 0.6〜1.8秒の追加待機
      };
      Object.assign(p, params);
      const gain = (x) => clamp01(p.baseGain + p.spread * Math.pow(1 - x, p.gainPow));
      const rBetween = (a,b)=> a + (b-a) * rnd();
      const ms = (m)=> m/1000;

      // id別プロファイル（fluorescent_timeline_sample.json を解析）
      // Peak @t≈1.085: 101:0.90, 102:0.95, 103:0.88, 104:0.82 → maxで正規化
      const peakWeights = new Map([[101, 0.90/0.95],[102,1.0],[103,0.88/0.95],[104,0.82/0.95]]);
      // Mid @t≈1.03: 101:0.24, 102:0.36, 103:0.12, 104:0.05 → maxで正規化
      const midWeights  = new Map([[101, 0.24/0.36],[102,1.0],[103,0.12/0.36],[104,0.05/0.36]]);
      // Near-zero @t≈1.402 等: 101:0.03, 102:0.06, 103:0.02, 104:0.01 → maxで正規化
      const zeroWeights = new Map([[101, 0.03/0.06],[102,1.0],[103,0.02/0.06],[104,0.01/0.06]]);
      function idWeight(id, phase){
        if (!p.useSampleIdProfiles) return 1.0;
        if (phase === 'peak') return peakWeights.get(id) ?? 1.0;
        if (phase === 'mid')  return midWeights.get(id)  ?? 1.0;
        if (phase === 'zero') return zeroWeights.get(id) ?? 1.0;
        return 1.0;
      }

      // エネルギー依存の空間成形: 低エネルギー時は中央を抑え、両端のみ赤く見せる
      function energyShapeFactor(x /*0..0.5*/, baseAmp){
        if (baseAmp < 0.28){
          // x=0（端）→1（中心）相当で中心側を大きく減衰
          const k = Math.min(1, Math.max(0, x / 0.5));
          return 1 - 0.75 * k; // 中央で最大-75%
        }
        return 1.0;
      }
      // 高エネルギー時の色温度確保: 全体が光る場合は黄〜白帯に持ち上げる
      function liftHighTempFloor(y, baseAmp){
        if (baseAmp > 0.82) return Math.max(y, 0.62);
        if (baseAmp > 0.70) return Math.max(y, 0.50);
        return y;
      }

      const keyframesGen = [];
      keyframesGen.push({ t: 0.0, points: controlPoints.map(cp=>({ id: cp.id, y: 0.0 })) });
      // 初回溜め（開始時刻）をランダム化：絶対レンジがあれば優先
      const hasAbs = Array.isArray(p.startTimeAbsRange) && p.startTimeAbsRange.length===2;
      const tStartCandidate = hasAbs ? rBetween(p.startTimeAbsRange[0], p.startTimeAbsRange[1])
                                     : duration * rBetween(p.startTimeRangeRel[0], p.startTimeRangeRel[1]);
      const tStart = clamp(tStartCandidate, 0.05, Math.max(0.2, duration - 0.2));
      
      // 全体構成のランダム化
      const firstPulseTime = rBetween(p.firstPulseDelayRange[0], p.firstPulseDelayRange[1]);
      const settleTime = duration * rBetween(p.settleTimeRangeRel[0], p.settleTimeRangeRel[1]);
      const targetPulseCount = Math.floor(rBetween(p.pulseCountRange[0], p.pulseCountRange[1] + 1));
      
      // 動的にdurationを計算（パルス生成時間 + 安定後0.5秒）
      let estimatedDuration = 0;
      
      let t = tStart;
      let cycle = 0;
      const settleBuffer = ms(p.settleBufferMs);
      const jitter = ()=> ms(rBetween(-p.globalJitterMs, p.globalJitterMs));
      const maybeRareLongTame = ()=> (rnd() < p.rareLongTameProb ? ms(rBetween(p.rareLongTameMsRange[0], p.rareLongTameMsRange[1])) : 0);

      // 1パルス（rise→hold→fall）のキーフレーム群を追加
      function addPulseAt(timeBase, baseAmp, cycleScale, isLast){
        // 最後のパルス専用の上書き設定（存在すれば優先）
        const riseRange = isLast && p.lastPulse && Array.isArray(p.lastPulse.pulseRiseMsRange) ? p.lastPulse.pulseRiseMsRange : p.pulseRiseMsRange;
        const holdRange = isLast && p.lastPulse && Array.isArray(p.lastPulse.pulseHoldMsRange) ? p.lastPulse.pulseHoldMsRange : p.pulseHoldMsRange;
        const fallRange = isLast && p.lastPulse && Array.isArray(p.lastPulse.pulseFallMsRange) ? p.lastPulse.pulseFallMsRange : p.pulseFallMsRange;
        const peakScale = isLast && p.lastPulse && typeof p.lastPulse.peakScale === 'number' ? p.lastPulse.peakScale : 1.0;
        const zeroClamp = isLast && p.lastPulse && typeof p.lastPulse.zeroClamp === 'number' ? p.lastPulse.zeroClamp : null;

        const rise = ms(rBetween(riseRange[0], riseRange[1]));
        const hold = ms(rBetween(holdRange[0], holdRange[1]));
        const fall = ms(rBetween(fallRange[0], fallRange[1]));
        const t0 = timeBase;
        const t1 = t0 + rise;            // 立ち上がり終端（中〜高の間）
        const t2 = t1 + hold;            // ピーク維持（短い）
        const t3 = t2 + fall;            // 近ゼロへ減衰（最後はスキップ可能）

        // 立ち上がり途中の中間点（プロファイルmid）
        const yMid = clamp01(baseAmp * (0.35 + 0.25 * rnd()));
        const mkPoints = (amp, phase)=> controlPoints.map(cp=>{
          const wId = idWeight(cp.id, phase);
          const shaped = (amp * peakScale) * cycleScale * wId * gain(cp.x) * energyShapeFactor(cp.x, amp * peakScale);
          let y = clamp01(shaped + rBetween(-p.noise, p.noise));
          y = liftHighTempFloor(y, amp);
          return { id: cp.id, y };
        });
        // t1: 立ち上がり終端（中間強度）
        keyframesGen.push({ t: t1, points: mkPoints(yMid, 'mid') });
        // t2: ピーク
        // 最後のパルスは全xで1.0固定
        if (isLast) {
          keyframesGen.push({ t: t2, points: controlPoints.map(cp=>({ id: cp.id, y: 1.0 })) });
        } else {
          keyframesGen.push({ t: t2, points: mkPoints(baseAmp, 'peak') });
        }
        // t3: 近ゼロ
        if (!isLast) {
          const yZeroBase = rBetween(p.zeroRange[0], p.zeroRange[1]);
          const zeroPts = controlPoints.map(cp=>{
            const zMul = idWeight(cp.id, 'zero');
            const shaped = yZeroBase * cycleScale * zMul * energyShapeFactor(cp.x, yZeroBase);
            let y = clamp01(shaped + rBetween(-p.noise*0.5, p.noise*0.5));
            if (zeroClamp != null) y = Math.min(y, zeroClamp);
            return { id: cp.id, y };
          });
          keyframesGen.push({ t: t3, points: zeroPts });
          return t3;
        } else {
          // 最後のパルスは暗くしない: 以降の最終状態は1.0へ統一
          return t2;
        }
      }

      // 1パルス目まで待機
      if (t < firstPulseTime) {
        t = firstPulseTime + maybeRareLongTame();
      }

      // 安定までのパルス生成（回数制御）
      let pulseCount = 0;
      while (pulseCount < targetPulseCount && t + settleBuffer < duration){
        const decay = Math.max(0.6, 1 - p.decayRate * cycle);
        // サイクルごとの強度スケール（±10%）
        const cycleScale = 0.90 + 0.20 * rnd();
        // バースト内のパルス数
        const nPulses = Math.max(1, Math.floor(rBetween(p.pulsesPerBurstRange[0], p.pulsesPerBurstRange[1] + 1)));
        for (let i=0;i<nPulses;i++){
          const isLastPulse = (pulseCount + i + 1) >= targetPulseCount; // これで全体の最後のパルスを検出
          const peakAmp = rBetween(p.peakRange[0], p.peakRange[1]) * decay;
          // パルス追加（鋭い→短い→即減衰）
          const tEnd = addPulseAt(t, peakAmp, cycleScale, isLastPulse);
          // ガウス分布でパルス間隔を生成
          const pulseInterval = gaussianRange(
            (p.pulseIntervalRange[0] + p.pulseIntervalRange[1]) / 2, // 平均
            p.pulseIntervalStdDev,                                    // 標準偏差
            p.pulseIntervalRange[0],                                  // 最小値
            p.pulseIntervalRange[1],                                  // 最大値
            rnd
          );
          t = tEnd + ms(pulseInterval) + jitter();
          if (t + settleBuffer >= duration) break;
          pulseCount++;
        }
        // 次の塊まで（ガウス分布でバースト間隔を生成）
        const burstInterval = gaussianRange(
          (p.burstIntervalRange[0] + p.burstIntervalRange[1]) / 2, // 平均
          p.burstIntervalStdDev,                                    // 標準偏差
          p.burstIntervalRange[0],                                  // 最小値
          p.burstIntervalRange[1],                                  // 最大値
          rnd
        );
        t += ms(burstInterval) + jitter() + maybeRareLongTame();
        cycle++;
      }

      // 最終状態に入る直前で暗転している場合があるため、直前KFを持ち上げ
      if (keyframesGen.length > 0) {
        const lastIdx = keyframesGen.length - 1;
        const lastKF = keyframesGen[lastIdx];
        const isDark = lastKF.points && lastKF.points.some(p=> (p?.y ?? 0) < 0.95);
        if (isDark) {
          lastKF.points = controlPoints.map(cp=>({ id: cp.id, y: 1.0 }));
        }
      }

      // 最終状態（安定後0.5秒）
      const finalDuration = t + p.stableTimeAfterSettle;
      keyframesGen.push({ t: finalDuration, points: controlPoints.map(cp=>({ id: cp.id, y: 1.0 })) });
      
      return { version, duration: finalDuration, controlPoints, keyframes: keyframesGen };
    }

    // 生成→読み込み ボタン
    genBtn && genBtn.addEventListener('click', ()=>{
      // サンプルに近い制御点配置（xは左半分 0..0.5）
      const cps = [
        { id: 101, x: 0.02 },
        { id: 102, x: 0.10 },
        { id: 103, x: 0.20 },
        { id: 104, x: 0.50 },
      ];
      const seed = (Date.now() & 0xffffffff) >>> 0;
      const timelineGen = generateFluorescentTimeline({
        duration: duration,
        controlPoints: cps,
        seed
      });

      // 内部形式（setKeyframesFromSpec）へ変換して反映
      const spec = timelineGen.keyframes.map(kf=>{
        const map = new Map(kf.points.map(p=>[p.id, p.y]));
        const pts = cps.map(cp=>({ id: cp.id, x: cp.x, y: clamp01(map.get(cp.id) ?? 0) }));
        return { t: kf.t, pts };
      });
      setKeyframesFromSpec(spec, timelineGen.duration);
      // 再生開始（任意）
      setPlaying(true);
    });

    function importJSONFile(file){
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          if (!data || !Array.isArray(data.keyframes)) throw new Error("invalid format: keyframes missing");
          const D = typeof data.duration === "number" ? data.duration : duration;

          // Strict schema with controlPoints
          const hasCP = Array.isArray(data.controlPoints);
          if (hasCP){
            // Validate controlPoints
            const cps = data.controlPoints.map(cp=>{
              const id = Number(cp.id);
              const xv = Number(cp.x);
              if (!Number.isFinite(id)) throw new Error("controlPoints: id must be a number");
              if (!Number.isFinite(xv)) throw new Error("controlPoints: x must be a number");
              const x = clamp(xv, 0, 0.5);
              return { id, x };
            });
            if (cps.length === 0) throw new Error("controlPoints must not be empty");
            // Unique ids
            const idSet = new Set();
            for (const cp of cps){
              if (idSet.has(cp.id)) throw new Error("duplicate controlPoint id: "+cp.id);
              idSet.add(cp.id);
            }
            // sort by x (stable)
            cps.sort((a,b)=> (a.x===b.x? a.id-b.id : a.x-b.x));

            // Validate each keyframe has exactly the same ids
            const idList = cps.map(cp=>cp.id);
            const spec = data.keyframes.map(entry=>{
              const t = clamp(+entry.t || 0, 0, D);
              const ptsRaw = Array.isArray(entry.points) ? entry.points : [];
              if (ptsRaw.length !== idList.length) throw new Error(`keyframe @t=${t}: points length mismatch`);
              const map = new Map(ptsRaw.map(p=>[+p.id||0, clamp(+p.y||0, 0, 1)]));
              // check all ids exist and no extras
              for (const id of idList){ if (!map.has(id)) throw new Error(`keyframe @t=${t}: missing id ${id}`); }
              if (map.size !== idList.length) throw new Error(`keyframe @t=${t}: contains unknown ids`);
              // build full points with x from controlPoints
              const pts = cps.map(cp=>({ id: cp.id, x: cp.x, y: map.get(cp.id) }));
              return { t, pts };
            });
            setKeyframesFromSpec(spec, D);
          } else {
            // Backward compatibility (legacy schema): validate consistent ids across frames
            const frames = data.keyframes;
            if (!Array.isArray(frames) || frames.length === 0) throw new Error("no keyframes");
            const firstPts = (frames[0].points||[]).map(p=>+p.id||0);
            const idSet0 = new Set(firstPts);
            const spec = frames.map(entry=>{
              const t = clamp(+entry.t || 0, 0, D);
              const ptsRaw = Array.isArray(entry.points) ? entry.points : [];
              const ids = ptsRaw.map(p=>+p.id||0);
              const idSetKF = new Set(ids);
              if (idSetKF.size !== idSet0.size) throw new Error(`keyframe @t=${t}: inconsistent point count`);
              for (const id of idSet0){ if (!idSetKF.has(id)) throw new Error(`keyframe @t=${t}: missing id ${id}`); }
              const pts = ptsRaw.map(p=>({ id:+p.id||0, x: clamp(+p.x||0,0,0.5), y: clamp(+p.y||0,0,1) }));
              return { t, pts: pts.length ? pts : shapeOff() };
            });
            setKeyframesFromSpec(spec, D);
          }
        } catch (err){
          alert("JSONの読み込みに失敗しました: " + err.message);
        }
      };
      reader.readAsText(file);
    }

    // ===== Drag & Drop JSON loader =====
    window.addEventListener('dragover', (e)=>{ e.preventDefault(); });
    window.addEventListener('drop', (e)=>{
      e.preventDefault();
      const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
      if (file && /\.json$/i.test(file.name)){
        importJSONFile(file);
      }
    });



    // Hook up buttons
    window.addEventListener('DOMContentLoaded', ()=>{});

    // ===== Initial =====
    function renderAll(){
      const cssW = getCssWidth();
      renderBar(cssW); renderAxis(cssW);
      renderLamp(cssW); renderLampAxis(cssW);
      renderCurve(cssW); renderTimeline(cssW);
    }

    (function init(){
      duration = Number(durationInput.value) || 2.0;
      loopPlay = !!loopChk.checked;
      initDefaultKeyframes();
      renderAll();
      syncTimeUI();
    })();
</script>
</body>
</html>
