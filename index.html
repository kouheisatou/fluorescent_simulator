<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>è›å…‰ç¯ã£ã½ã„å››è§’ï¼ˆç‚¹ç¯ç‡ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼ãƒ”ãƒ¼ã‚¯å›ºå®š0.05ï¼æ©™â†’é»„â†’ç™½ï¼‰</title>
<style>
  :root { --bg:#0e0f12; --panel:#14161b; --text:#e7eaf0; }
  html,body { margin:0; padding:0; background:var(--bg); color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif; }
  .wrap{ max-width: 900px; margin: 20px auto; padding: 16px; background:var(--panel);
    border-radius: 16px; box-shadow: 0 16px 40px rgba(0,0,0,.35); }
  h1{ font-size:1.1rem; margin:0 0 12px; letter-spacing:.01em; }
  .row{ display:flex; align-items:center; gap:12px; margin-top:10px; }
  .grow{ flex:1 1 auto; }
  input[type=range]{ width:100%; }
  #lamp{ display:block; width:100%; height:auto; border-radius: 0px; background:#0b0c0f; margin-top:10px; }
  .hint{ opacity:.9; font-size:.92rem; line-height:1.6; margin-top:10px; }
  code{ background:#11131a; padding:2px 6px; border-radius:6px; }
  label{ width:240px; opacity:.9; }
  .val{ width:120px; text-align:right; }
.timeline{ display:block; width:100%; height:auto; background:#0b0c0f; border:1px solid rgba(255,255,255,0.12); user-select:none; }
.tiny{ font-size:12px; opacity:.8; }
button{ background:#1b1e24; color:#e7eaf0; border:1px solid rgba(255,255,255,.12); padding:6px 10px; border-radius:8px; cursor:pointer; }
button:hover{ background:#212530; }
input[type=number]{ width:80px; background:#1b1e24; color:#e7eaf0; border:1px solid rgba(255,255,255,.12); border-radius:6px; padding:4px 6px; }
</style>
</head>
<body>
  <div class="wrap">
    <h1>è›å…‰ç¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</h1>

    <div class="row">
      <label for="t">ç‚¹ç¯ç‡ t</label>
      <div class="grow"><input id="t" type="range" min="0" max="1" step="0.001" value="0" /></div>
      <div class="val"><span id="tVal">0.000</span></div>
    </div>

    <div class="row">
      <label for="sigma">æ¸›è¡°ç‡ Ïƒï¼ˆãƒ”ãƒ¼ã‚¯ã‹ã‚‰ã®åºƒãŒã‚Šï¼‰</label>
      <div class="grow"><input id="sigma" type="range" min="0.005" max="0.500" step="0.001" value="0.060" /></div>
      <div class="val"><span id="sigmaVal">0.060</span></div>
    </div>

    <div class="row">
      <label for="peakPos">ãƒ”ãƒ¼ã‚¯ä½ç½®ï¼ˆç«¯ã‹ã‚‰ã®è·é›¢ï¼‰</label>
      <div class="grow"><input id="peakPos" type="range" min="0.02" max="0.20" step="0.001" value="0.05" /></div>
      <div class="val"><span id="peakPosVal">0.050</span></div>
    </div>

    <div class="row">
      <label for="lampLength">è›å…‰ç¯ã®é•·ã•ï¼ˆç›¸å¯¾çš„ï¼‰</label>
      <div class="grow"><input id="lampLength" type="range" min="0.3" max="3.0" step="0.01" value="0.92" /></div>
      <div class="val"><span id="lampLengthVal">0.92</span></div>
    </div>

    <!-- ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ï¼ˆtï¼‰ -->
    <div class="row" style="align-items:center; margin-top:8px;">
      <label class="tiny" style="width:auto;">t ã®ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ï¼ˆ0â†’1ï¼‰</label>
    </div>
    <canvas id="timelineT" width="1024" height="140" class="timeline"></canvas>

    <!-- ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ï¼ˆÏƒï¼‰ -->
    <div class="row" style="align-items:center; margin-top:8px;">
      <label class="tiny" style="width:auto;">Ïƒ ã®ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ï¼ˆ0.02â†’0.20ï¼‰</label>
    </div>
    <canvas id="timelineS" width="1024" height="140" class="timeline"></canvas>

    <!-- å†ç”Ÿã‚·ãƒ¼ã‚±ãƒ³ã‚¹è¡¨ç¤º -->
    <div class="row" style="align-items:center; margin-top:12px;">
      <label class="tiny" style="width:auto;">å†ç”Ÿã‚·ãƒ¼ã‚±ãƒ³ã‚¹</label>
    </div>
    <canvas id="playbackSequence" width="1024" height="60" class="timeline"></canvas>

    <!-- å†ç”Ÿã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
    <div class="row" style="align-items:center;gap:8px; margin-top:8px;">
      <button id="playPause">â–¶ï¸ å†ç”Ÿ</button>
      <button id="exportVideo">ğŸ“¹ å‹•ç”»å‡ºåŠ›</button>
      <label style="width:auto;">é•·ã•(ç§’)</label>
      <input id="duration" type="number" min="0.5" max="30" step="0.1" value="4.0"/>
      <label style="width:auto; display:flex; align-items:center; gap:6px;">
        <input id="loop" type="checkbox" /> ãƒ«ãƒ¼ãƒ—
      </label>
      <div class="val" style="width:auto;">t=<span id="timeVal">0.00</span>s</div>
      <div class="val" style="width:auto; opacity:0.7;">(ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼: å†ç”Ÿ/åœæ­¢)</div>
    </div>

    <canvas id="lamp" width="1024" height="220"></canvas>

    <p class="hint">
      <b>ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æ“ä½œ:</b><br>
      â€¢ ç©ºã„ã¦ã„ã‚‹å ´æ‰€ã‚’ã‚¯ãƒªãƒƒã‚¯ â†’ æ–°ã—ã„ç‚¹ã‚’è¿½åŠ <br>
      â€¢ ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ â†’ å˜ä½“é¸æŠï¼ˆèµ¤è‰²ã§è¡¨ç¤ºï¼‰<br>
      â€¢ é¸æŠã—ãŸç‚¹ã‚’ãƒ‰ãƒ©ãƒƒã‚° â†’ ä½ç½®ã‚’ç§»å‹•<br>
      â€¢ Shift + ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ â†’ è¤‡æ•°é¸æŠï¼ˆé¸æŠã—ãŸç‚¹ã‚’ã¾ã¨ã‚ã¦ç§»å‹•å¯èƒ½ï¼‰<br>
      â€¢ Backspace/Delete â†’ é¸æŠã—ãŸç‚¹ã‚’å‰Šé™¤<br>
      â€¢ Esc â†’ é¸æŠè§£é™¤<br><br>
      <b>å†ç”Ÿã‚·ãƒ¼ã‚±ãƒ³ã‚¹:</b><br>
      â€¢ ã‚¯ãƒªãƒƒã‚¯ã§å†ç”Ÿä½ç½®ã‚’å¤‰æ›´<br>
      â€¢ è‰²ã®æ¿ƒã•ãŒç‚¹ç¯ã®å¼·ã•ã€ä¸‹éƒ¨ã®ç·šãŒÏƒã®å€¤ã‚’è¡¨ç¤º<br><br>
      <b>å‹•ç”»å‡ºåŠ›:</b><br>
      â€¢ ğŸ“¹ãƒœã‚¿ãƒ³ã§60fps WebMå‹•ç”»ã¨ã—ã¦å‡ºåŠ›ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼‰
    </p>
  </div>

<script>
// ======================= Utils =======================
const clamp01 = x => Math.max(0, Math.min(1, x));
const mix = (a,b,t) => a*(1-t) + b*t;
const smoothstep01 = x => { x = clamp01(x); return x*x*(3-2*x); };
const invlerp = (a,b,x) => (x-a)/((b-a)+1e-9);
function gauss(x, m, s){ const z=(x-m)/(s+1e-9); return Math.exp(-0.5*z*z); }

// ======================= Model =======================
let CFG = { OFFSET: 0.05 }; // ç«¯ã‹ã‚‰ã®è·é›¢ï¼ˆå‹•çš„ã«å¤‰æ›´å¯èƒ½ï¼‰

// ãƒ•ã‚§ãƒ¼ã‚º: A=æ©™æ‹¡æ•£(0..0.80), B=æ©™â†’é»„(0.80..0.90), C=é»„â†’ç™½æ‹¡æ•£(0.90..0.98), D=å‡ä¸€ç™½(0.98..1.00)
function phases(t){
  return {
    A: smoothstep01(invlerp(0.00, 0.80, t)),
    B: smoothstep01(invlerp(0.80, 0.90, t)),
    C: smoothstep01(invlerp(0.90, 0.98, t)),
    D: smoothstep01(invlerp(0.98, 1.00, t)),
  };
}

// ä¸»é–¢æ•°: tâˆˆ[0,1], uâˆˆ[0,1], sigmaâˆˆ[0.005,0.50], peakPosâˆˆ[0.02,0.20], lampLength -> [r,g,b,a]
function lampColorAt(t, u, sigma, peakPos = 0.05, lampLength = 1.0){
  t = clamp01(t); u = clamp01(u); sigma = clamp01((sigma-0.005)/0.495); // æ­£è¦åŒ–(0..1)
  const {A,B,C,D} = phases(t);

  // è›å…‰ç¯ã®é•·ã•ã«å¿œã˜ã¦Ïƒã‚’èª¿æ•´ï¼ˆé•·ã„ã»ã©é‹­ãï¼‰
  // é•·ã„è›å…‰ç¯ï¼ˆ1.5å€ä»¥ä¸Šï¼‰ã§ã¯å¤§å¹…ã«é‹­ãã™ã‚‹
  let lengthFactor = 1.0;
  if (lampLength > 1.5) {
    // 1.5å€ã‚’è¶…ãˆã‚‹å ´åˆã€æ€¥æ¿€ã«é‹­ãã™ã‚‹
    lengthFactor = Math.max(0.2, 0.8 / lampLength);
  } else if (lampLength > 1.0) {
    // 1.0-1.5å€ã®å ´åˆã€å¾ã€…ã«é‹­ãã™ã‚‹
    lengthFactor = 1.0 - (lampLength - 1.0) * 0.6;
  }
  const adjustedSigma = sigma * lengthFactor;

  // Aã§æš–è‰²ã®åºƒãŒã‚ŠãŒå¢—ãˆã‚‹ï¼ˆé•·ã•èª¿æ•´æ¸ˆã¿Ïƒã‚’ä½¿ç”¨ã€ã‚ˆã‚Šåºƒã„ç¯„å›²å¯¾å¿œï¼‰
  const sigmaWarm = 0.005 + 0.495 * mix(0.8, 1.8, A) * (0.01 + 0.99*((adjustedSigma*0.85)+0.15));
  const off = peakPos; // ãƒ”ãƒ¼ã‚¯ä½ç½®ã‚’ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰å–å¾—

  // å·¦å³ãƒ”ãƒ¼ã‚¯ï¼ˆæ­£è¦åŒ–ï¼‰
  let S = gauss(u, off, sigmaWarm) + gauss(u, 1-off, sigmaWarm);
  const Smax = 1 + Math.exp(-Math.pow(1 - 2*off, 2) / (2*sigmaWarm*sigmaWarm));
  S = Math.min(1, S / Smax);

  // é»„ã®å‡ºç¾ï¼ˆç™½ã‚ˆã‚Šå…ˆã«å‡ºã‚‹ï¼‰ã€‚Bã§ãƒ”ãƒ¼ã‚¯è¿‘å‚ã€C/Dã§æ¸›è¡°
  const yellowLocal = Math.pow(S, 0.9) * B * (1 - 0.55*C) * (1 - 0.7*D);

  // ç™½ã®æ‹¡æ•£ï¼šCã§ãƒ”ãƒ¼ã‚¯ä¸­å¿ƒã‹ã‚‰æ‹¡å¤§ã€Dã§å…¨é¢ç™½ï¼ˆã‚ˆã‚Šåºƒã„ç¯„å›²å¯¾å¿œï¼‰
  const dToPeaks = Math.min(Math.abs(u-off), Math.abs(u-(1-off)));
  const sigmaSpreadMax = 0.05 + 0.95 * (0.10 + 0.90*adjustedSigma); // èª¿æ•´æ¸ˆã¿Ïƒã«å¿œã˜ã¦æœ€å¤§åŠå¾„
  const sigmaSpread = sigmaSpreadMax * C;
  const whiteSpread = sigmaSpread>0.001 ? Math.exp(-0.5 * (dToPeaks/sigmaSpread)**2) : 0.0;
  let whiteWeight = clamp01( Math.pow(S, 0.9)*B*0.12 + 0.88*whiteSpread );
  whiteWeight = mix(whiteWeight, 1.0, D);

  // è¼åº¦
  let brightness = 0.0
    + 0.72 * (A * Math.pow(S, 1.1))
    + 0.55 * (B * Math.pow(S, 1.0))
    + 0.50 * C * (0.25 + 0.75*whiteSpread)
    + 0.60 * D;
  brightness = Math.pow(clamp01(brightness), 0.9);

  // è‰²ï¼šæ©™â†’é»„â†’ç™½
  const ORANGE = [255, 112, 54];
  const YELLOW = [255, 224, 110];
  const WHITE  = [248, 252, 255];

  const yk = clamp01(yellowLocal);
  const baseR = mix(ORANGE[0], YELLOW[0], yk);
  const baseG = mix(ORANGE[1], YELLOW[1], yk);
  const baseB = mix(ORANGE[2], YELLOW[2], yk);

  const r = mix(baseR, WHITE[0], whiteWeight);
  const g = mix(baseG, WHITE[1], whiteWeight);
  const b = mix(baseB, WHITE[2], whiteWeight);
  const alpha = brightness; // 0..1 â€” t=0 ã§ 0ï¼ˆå®Œå…¨é€æ˜ï¼‰
  return [r|0, g|0, b|0, Math.round(alpha*255)];
}

// ======================= Rendering =======================
function drawLamp(ctx, t, sigma, peakPos = 0.05, lampLength = 0.92){
  const W = ctx.canvas.width, H = ctx.canvas.height;
  ctx.clearRect(0,0,W,H);

  // èƒŒæ™¯ï¼ˆå£ï¼‰
  const wall = ctx.createLinearGradient(0,0,0,H);
  wall.addColorStop(0, '#0b0c0f');
  wall.addColorStop(1, '#0e0f12');
  ctx.fillStyle = wall;
  ctx.fillRect(0,0,W,H);

  // ãƒ©ãƒ³ãƒ—ç­ä½“ï¼ˆé•·ã•ã‚’èª¿æ•´ã€å¿…è¦ã«å¿œã˜ã¦å…¨ä½“ã‚’ç¸®å°ï¼‰
  const basePadX = Math.floor(W*0.04);
  const padY = Math.floor(H*0.32);
  const baseFullWidth = W - basePadX*2;
  const desiredWidth = Math.floor(baseFullWidth * lampLength);
  
  // ã¯ã¿å‡ºã™å ´åˆã¯å…¨ä½“ã‚’ç¸®å°
  let scaleFactor = 1.0;
  let padX = basePadX;
  let fullWidth = baseFullWidth;
  let rw = desiredWidth;
  
  if (desiredWidth > baseFullWidth) {
    // ç¸®å°ãŒå¿…è¦
    scaleFactor = baseFullWidth / desiredWidth;
    rw = baseFullWidth;
    // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚‚ç¸®å°
    padX = Math.floor(basePadX * scaleFactor);
    fullWidth = W - padX*2;
    rw = Math.floor(fullWidth);
  }
  
  const rh = Math.floor(H*0.36 * scaleFactor); // é«˜ã•ã‚‚æ¯”ä¾‹ã—ã¦ç¸®å°
  const lampStartX = padX + Math.floor((fullWidth - rw) / 2); // ä¸­å¤®å¯„ã›

  // ä¸Šå´ã®ç­ä½“å½±ï¼ˆè›å…‰ç¯ã®å¹…ã«åˆã‚ã›ã‚‹ã€ç¸®å°ã‚‚è€ƒæ…®ï¼‰
  const shadowHeight = Math.floor(22 * scaleFactor);
  const sh = ctx.createLinearGradient(0, padY-shadowHeight, 0, padY);
  sh.addColorStop(0, 'rgba(0,0,0,0.75)');
  sh.addColorStop(1, 'rgba(0,0,0,0.00)');
  ctx.fillStyle = sh; ctx.fillRect(lampStartX, padY-shadowHeight, rw, shadowHeight);

  // è§’ãªã—ã‚¯ãƒªãƒƒãƒ—
  ctx.save(); ctx.beginPath(); ctx.rect(lampStartX, padY, rw, rh); ctx.clip();

  // ãƒ™ãƒ¼ã‚¹ï¼ˆæ¿ƒã„ã‚°ãƒ¬ãƒ¼ï¼‰
  ctx.fillStyle = 'rgb(60,60,60)';
  ctx.fillRect(lampStartX, padY, rw, rh);

  // ç™ºå…‰é¢ï¼ˆæ¨ªæ–¹å‘256ã‚µãƒ³ãƒ—ãƒ«ï¼‰
  const L = 256; const strip = ctx.createImageData(L, rh);
  for(let y=0;y<rh;y++){
    for(let x=0;x<L;x++){
      const u = x/(L-1);
      const [r,g,b,a] = lampColorAt(t, u, sigma, peakPos, lampLength);
      const i = (y*L + x)*4; strip.data[i]=r; strip.data[i+1]=g; strip.data[i+2]=b; strip.data[i+3]=a;
    }
  }
  const tmp = document.createElement('canvas'); tmp.width=L; tmp.height=rh;
  tmp.getContext('2d').putImageData(strip, 0, 0);
  ctx.imageSmoothingEnabled = true; ctx.drawImage(tmp, lampStartX, padY, rw, rh);

  // ç«¯ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆç„¡ç‚¹ç¯æ™‚ã¯æã‹ãªã„ã€ç¸®å°ã‚‚è€ƒæ…®ï¼‰
  if (t > 0.0001) {
    const edgeWidth = Math.floor(rw*0.12);
    const edgeL = ctx.createLinearGradient(lampStartX,0,lampStartX+edgeWidth,0);
    edgeL.addColorStop(0, 'rgba(255,255,255,0.18)'); edgeL.addColorStop(1,'rgba(255,255,255,0.00)');
    ctx.fillStyle = edgeL; ctx.fillRect(lampStartX, padY, edgeWidth, rh);

    const edgeR = ctx.createLinearGradient(lampStartX+rw-edgeWidth,0,lampStartX+rw,0);
    edgeR.addColorStop(0, 'rgba(255,255,255,0.00)'); edgeR.addColorStop(1,'rgba(255,255,255,0.18)');
    ctx.fillStyle = edgeR; ctx.fillRect(lampStartX+rw-edgeWidth, padY, edgeWidth, rh);
  }

  ctx.restore();
}



// ======================= Playback Sequence Display =======================
class PlaybackSequence{
  constructor(canvas){
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.isDragging = false;
    this.setupMouseEvents();
  }
  
  setupMouseEvents(){
    this.canvas.style.cursor = 'pointer';
    this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
    this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
    this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
    this.canvas.addEventListener('mouseleave', (e) => this.onMouseLeave(e));
  }
  
  getMousePos(e){
    const rect = this.canvas.getBoundingClientRect();
    const scaleX = this.canvas.width / rect.width;
    return {
      x: (e.clientX - rect.left) * scaleX
    };
  }
  
  onMouseDown(e){
    const pos = this.getMousePos(e);
    const playheadX = (playhead / duration) * this.canvas.width;
    
    // å†ç”Ÿãƒ˜ãƒƒãƒ‰ã®è¿‘ãã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
    if(Math.abs(pos.x - playheadX) < 10) {
      this.isDragging = true;
      this.canvas.style.cursor = 'grabbing';
      // å†ç”Ÿã‚’åœæ­¢
      playing = false;
      playBtn.textContent = 'â–¶ï¸ å†ç”Ÿ';
    } else {
      // é€šå¸¸ã®ã‚¯ãƒªãƒƒã‚¯ - å†ç”Ÿä½ç½®å¤‰æ›´
      const clickTime = (pos.x / this.canvas.width) * duration;
      playhead = Math.max(0, Math.min(duration, clickTime));
      syncFromTracks();
      redrawTimelines();
    }
  }
  
  onMouseMove(e){
    const pos = this.getMousePos(e);
    
    if(this.isDragging) {
      // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ - å†ç”Ÿä½ç½®ã‚’æ›´æ–°
      const newTime = (pos.x / this.canvas.width) * duration;
      playhead = Math.max(0, Math.min(duration, newTime));
      syncFromTracks();
      redrawTimelines();
    } else {
      // ãƒ›ãƒãƒ¼åŠ¹æœ
      const playheadX = (playhead / duration) * this.canvas.width;
      this.canvas.style.cursor = Math.abs(pos.x - playheadX) < 10 ? 'grab' : 'pointer';
    }
  }
  
  onMouseUp(e){
    if(this.isDragging) {
      this.isDragging = false;
      this.canvas.style.cursor = 'pointer';
    }
  }
  
  onMouseLeave(e){
    if(this.isDragging) {
      this.isDragging = false;
    }
    this.canvas.style.cursor = 'pointer';
  }
  
  draw(){
    const ctx = this.ctx, W = this.canvas.width, H = this.canvas.height;
    ctx.clearRect(0, 0, W, H);
    
    // èƒŒæ™¯
    ctx.fillStyle = '#0b0c0f';
    ctx.fillRect(0, 0, W, H);
    
    // ã‚°ãƒªãƒƒãƒ‰ç·šï¼ˆæ™‚é–“è»¸ï¼‰
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i = 0; i <= 10; i++){
      const x = i / 10 * W;
      ctx.moveTo(x, 0);
      ctx.lineTo(x, H);
    }
    ctx.stroke();
    
    // ç¾åœ¨ã®å†ç”Ÿä½ç½®ã‚’å¯è¦–åŒ–
    const sections = 20; // ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ•°
    const sectionWidth = W / sections;
    
    for(let i = 0; i < sections; i++){
      const time = (i / sections) * duration;
      const t = tTrack.valueAt(time);
      const sigma = sTrack.valueAt(time);
      
      // tã®å€¤ã«åŸºã¥ã„ã¦è‰²ã‚’æ±ºå®š
      let intensity = t;
      let color;
      
      if(t < 0.1){
        color = `rgba(50, 50, 50, ${intensity})`;
      } else if(t < 0.8){
        // ã‚ªãƒ¬ãƒ³ã‚¸ç³»
        const orange = Math.floor(255 * intensity);
        const red = Math.floor(255 * intensity * 0.8);
        color = `rgba(${orange}, ${red}, 0, ${intensity})`;
      } else {
        // ç™½ç³»
        const white = Math.floor(255 * intensity);
        color = `rgba(${white}, ${white}, ${white}, ${intensity})`;
      }
      
      ctx.fillStyle = color;
      ctx.fillRect(i * sectionWidth, H * 0.2, sectionWidth - 1, H * 0.6);
      
      // Ïƒã®å€¤ã‚’é«˜ã•ã§è¡¨ç¾ï¼ˆè–„ã„ç·šï¼‰
      const sigmaHeight = ((sigma - 0.02) / (0.20 - 0.02)) * H * 0.15;
      ctx.fillStyle = 'rgba(255, 212, 124, 0.5)';
      ctx.fillRect(i * sectionWidth, H * 0.85 - sigmaHeight, sectionWidth - 1, sigmaHeight);
    }
    
    // å†ç”Ÿãƒ˜ãƒƒãƒ‰
    const xh = (playhead / duration) * W;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(xh, 0);
    ctx.lineTo(xh, H);
    ctx.stroke();
    
    // æ™‚é–“ãƒ©ãƒ™ãƒ«
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.font = '10px system-ui, -apple-system, Segoe UI, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    for(let i = 0; i <= 10; i++){
      const time = (i / 10) * duration;
      const x = i / 10 * W;
      if(x + 30 < W || i === 0){
        ctx.fillText(`${time.toFixed(1)}s`, x + 2, 2);
      }
    }
  }
}

// ======================= Timeline graph & playback =======================
class Track{
  constructor(canvas, {min, max, color, label, keys=[]}){
    this.canvas = canvas; this.ctx = canvas.getContext('2d');
    this.min=min; this.max=max; this.color=color; this.label=label; this.keys=keys;
    this.isDragging = false;
    this.dragIndex = -1;
    this.dragOffset = {x: 0, y: 0};
    this.mouseDownPos = {x: 0, y: 0};
    this.hasMoved = false;
    
    // è¤‡æ•°é¸æŠæ©Ÿèƒ½
    this.selectedPoints = new Set();
    this.isDraggingMultiple = false;
    this.multiDragOffsets = new Map();
    
    this.setupMouseEvents();
  }
  setKeys(keys){ this.keys = keys.slice().sort((a,b)=>a.time-b.time); }
  timeToX(t){ return (t/duration) * this.canvas.width; }
  valueToY(v){ return (1 - (v - this.min)/(this.max - this.min)) * (this.canvas.height-1); }
  valueAt(t){
    if(!this.keys.length) return 0;
    if(t<=this.keys[0].time) return this.keys[0].value;
    if(t>=this.keys[this.keys.length-1].time) return this.keys[this.keys.length-1].value;
    for(let i=0;i<this.keys.length-1;i++){
      const a=this.keys[i], b=this.keys[i+1];
      if(t>=a.time && t<=b.time){ const u=(t-a.time)/((b.time-a.time)||1e-9); return a.value + (b.value-a.value)*u; }
    }
    return this.keys[this.keys.length-1].value;
  }
  draw(){
    const ctx=this.ctx, W=this.canvas.width, H=this.canvas.height; ctx.clearRect(0,0,W,H);
    ctx.fillStyle='#0b0c0f'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1; ctx.beginPath();
    for(let i=0;i<=10;i++){ const x=i/10*W; ctx.moveTo(x,0); ctx.lineTo(x,H);} ctx.stroke();
    ctx.fillStyle='rgba(255,255,255,0.8)'; ctx.font='12px system-ui, -apple-system, Segoe UI, sans-serif'; ctx.textBaseline='top'; ctx.fillText(`${this.label}`, 6, 4);
    if(this.keys.length){
      ctx.strokeStyle=this.color; ctx.lineWidth=2; ctx.beginPath();
      for(let i=0;i<this.keys.length;i++){
        const x=this.timeToX(this.keys[i].time), y=this.valueToY(this.keys[i].value);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      for(let i=0;i<this.keys.length;i++){
        const x=this.timeToX(this.keys[i].time), y=this.valueToY(this.keys[i].value);
        const isSelected = this.selectedPoints.has(i);
        
        // é¸æŠã•ã‚ŒãŸç‚¹ã¯ç•°ãªã‚‹è‰²ã§è¡¨ç¤º
        ctx.fillStyle = isSelected ? '#ff6b6b' : '#1b1e24';
        ctx.beginPath(); 
        ctx.arc(x, y, isSelected ? 5 : 4, 0, Math.PI*2); 
        ctx.fill();
        ctx.strokeStyle = isSelected ? '#ff4444' : this.color; 
        ctx.lineWidth = isSelected ? 3 : 2; 
        ctx.stroke();
      }
      const xh = this.timeToX(playhead); ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(xh,0); ctx.lineTo(xh,H); ctx.stroke();
    }
  }

  setupMouseEvents(){
    this.canvas.style.cursor = 'pointer';
    
    this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
    this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
    this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
    this.canvas.addEventListener('mouseleave', (e) => this.onMouseLeave(e));
  }

  getMousePos(e){
    const rect = this.canvas.getBoundingClientRect();
    const scaleX = this.canvas.width / rect.width;
    const scaleY = this.canvas.height / rect.height;
    return {
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top) * scaleY
    };
  }

  findNearestPoint(x, y){
    let nearest = -1;
    let minDist = Infinity;
    const threshold = 12; // ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šã®é–¾å€¤ã‚’å°‘ã—å¤§ããã—ã¦æ“ä½œã—ã‚„ã™ã
    
    for(let i = 0; i < this.keys.length; i++){
      const px = this.timeToX(this.keys[i].time);
      const py = this.valueToY(this.keys[i].value);
      const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
      if(dist < threshold && dist < minDist){
        minDist = dist;
        nearest = i;
      }
    }
    return nearest;
  }

  xToTime(x){
    return Math.max(0, Math.min(duration, (x / this.canvas.width) * duration));
  }

  yToValue(y){
    const normalized = 1 - (y / (this.canvas.height - 1));
    return Math.max(this.min, Math.min(this.max, this.min + normalized * (this.max - this.min)));
  }

  onMouseDown(e){
    const pos = this.getMousePos(e);
    const nearestIndex = this.findNearestPoint(pos.x, pos.y);
    
    this.mouseDownPos = {x: pos.x, y: pos.y};
    this.hasMoved = false;
    
    if(nearestIndex >= 0){
      if(e.shiftKey){
        // ã‚·ãƒ•ãƒˆã‚¯ãƒªãƒƒã‚¯ - è¤‡æ•°é¸æŠ
        if(this.selectedPoints.has(nearestIndex)){
          this.selectedPoints.delete(nearestIndex);
        } else {
          this.selectedPoints.add(nearestIndex);
        }
        this.draw();
      } else {
        // é€šå¸¸ã‚¯ãƒªãƒƒã‚¯ - é¸æŠã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°æº–å‚™
        if(this.selectedPoints.size > 0){
          // æ—¢ã«é¸æŠãŒã‚ã‚‹å ´åˆ
          if(!this.selectedPoints.has(nearestIndex)){
            // é¸æŠã•ã‚Œã¦ã„ãªã„ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ - é¸æŠã‚’å¤‰æ›´
            this.selectedPoints.clear();
            this.selectedPoints.add(nearestIndex);
            this.draw();
          } else {
            // é¸æŠæ¸ˆã¿ã®ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ - ã¾ã¨ã‚ã¦ãƒ‰ãƒ©ãƒƒã‚°æº–å‚™
            this.isDraggingMultiple = true;
            this.setupMultiDrag(pos);
          }
        } else {
          // é¸æŠãŒãªã„å ´åˆ - å˜ä¸€é¸æŠã—ã¦ãƒ‰ãƒ©ãƒƒã‚°æº–å‚™
          this.selectedPoints.add(nearestIndex);
          this.isDragging = true;
          this.dragIndex = nearestIndex;
          const px = this.timeToX(this.keys[nearestIndex].time);
          const py = this.valueToY(this.keys[nearestIndex].value);
          this.dragOffset = { x: pos.x - px, y: pos.y - py };
          this.canvas.style.cursor = 'grabbing';
          this.draw();
        }
      }
    } else {
      // ç©ºã„ã¦ã„ã‚‹ã¨ã“ã‚ã‚’ã‚¯ãƒªãƒƒã‚¯
      if(!e.shiftKey){
        // é€šå¸¸ã‚¯ãƒªãƒƒã‚¯ - é¸æŠè§£é™¤ã—ã¦æ–°ã—ã„ç‚¹ã‚’è¿½åŠ 
        this.selectedPoints.clear();
        const newTime = this.xToTime(pos.x);
        const newValue = this.yToValue(pos.y);
        this.keys.push({ time: newTime, value: newValue });
        this.keys.sort((a, b) => a.time - b.time);
        this.draw();
        syncFromTracks();
      }
    }
  }

  setupMultiDrag(pos){
    this.multiDragOffsets.clear();
    for(const index of this.selectedPoints){
      const px = this.timeToX(this.keys[index].time);
      const py = this.valueToY(this.keys[index].value);
      this.multiDragOffsets.set(index, { x: pos.x - px, y: pos.y - py });
    }
    this.canvas.style.cursor = 'grabbing';
  }

  onMouseMove(e){
    const pos = this.getMousePos(e);
    
    if(this.isDraggingMultiple){
      // è¤‡æ•°ç‚¹ã®ãƒ‰ãƒ©ãƒƒã‚°ä¸­
      const dragDistance = Math.sqrt(
        Math.pow(pos.x - this.mouseDownPos.x, 2) + 
        Math.pow(pos.y - this.mouseDownPos.y, 2)
      );
      
      if(dragDistance > 3){
        this.hasMoved = true;
      }
      
      // é¸æŠã•ã‚ŒãŸå…¨ã¦ã®ç‚¹ã‚’ç§»å‹•
      const newPositions = new Map();
      for(const index of this.selectedPoints){
        const offset = this.multiDragOffsets.get(index);
        const newTime = this.xToTime(pos.x - offset.x);
        const newValue = this.yToValue(pos.y - offset.y);
        newPositions.set(index, { time: newTime, value: newValue });
      }
      
      // æ–°ã—ã„ä½ç½®ã‚’é©ç”¨
      for(const [index, newPos] of newPositions){
        this.keys[index].time = newPos.time;
        this.keys[index].value = newPos.value;
      }
      
      this.keys.sort((a, b) => a.time - b.time);
      this.draw();
      syncFromTracks();
      
    } else if(this.isDragging && this.dragIndex >= 0){
      // å˜ä¸€ç‚¹ã®ãƒ‰ãƒ©ãƒƒã‚°ä¸­
      const dragDistance = Math.sqrt(
        Math.pow(pos.x - this.mouseDownPos.x, 2) + 
        Math.pow(pos.y - this.mouseDownPos.y, 2)
      );
      
      if(dragDistance > 3){
        this.hasMoved = true;
      }
      
      const newTime = this.xToTime(pos.x - this.dragOffset.x);
      const newValue = this.yToValue(pos.y - this.dragOffset.y);
      
      this.keys[this.dragIndex].time = newTime;
      this.keys[this.dragIndex].value = newValue;
      this.keys.sort((a, b) => a.time - b.time);
      
      // ã‚½ãƒ¼ãƒˆå¾Œã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
      for(let i = 0; i < this.keys.length; i++){
        if(this.keys[i].time === newTime && this.keys[i].value === newValue){
          this.dragIndex = i;
          break;
        }
      }
      
      this.draw();
      syncFromTracks();
    } else {
      // ãƒ›ãƒãƒ¼åŠ¹æœ
      const nearestIndex = this.findNearestPoint(pos.x, pos.y);
      this.canvas.style.cursor = nearestIndex >= 0 ? 'grab' : 'crosshair';
    }
  }

  onMouseUp(e){
    if(this.isDraggingMultiple){
      this.isDraggingMultiple = false;
      this.multiDragOffsets.clear();
      this.hasMoved = false;
      this.canvas.style.cursor = 'pointer';
    } else if(this.isDragging){
      this.isDragging = false;
      this.dragIndex = -1;
      this.hasMoved = false;
      this.canvas.style.cursor = 'pointer';
    }
  }

  onMouseLeave(e){
    if(this.isDraggingMultiple){
      this.isDraggingMultiple = false;
      this.multiDragOffsets.clear();
      this.hasMoved = false;
    } else if(this.isDragging){
      this.isDragging = false;
      this.dragIndex = -1;
      this.hasMoved = false;
    }
    this.canvas.style.cursor = 'pointer';
  }

  // é¸æŠã•ã‚ŒãŸç‚¹ã‚’å‰Šé™¤
  deleteSelectedPoints(){
    if(this.selectedPoints.size === 0) return false;
    
    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’é™é †ã§ã‚½ãƒ¼ãƒˆã—ã¦å‰Šé™¤ï¼ˆå¾Œã‚ã‹ã‚‰å‰Šé™¤ã™ã‚‹ã“ã¨ã§ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ãšã‚Œã‚’é˜²ãï¼‰
    const indicesToDelete = Array.from(this.selectedPoints).sort((a, b) => b - a);
    
    for(const index of indicesToDelete){
      this.keys.splice(index, 1);
    }
    
    this.selectedPoints.clear();
    this.draw();
    syncFromTracks();
    return true;
  }

  // é¸æŠã‚’è§£é™¤
  clearSelection(){
    if(this.selectedPoints.size === 0) return false;
    this.selectedPoints.clear();
    this.draw();
    return true;
  }
}

// ãƒ—ãƒªã‚»ãƒƒãƒˆ: 3å›ç‚¹æ»…ï¼ˆãŸã‚â†’ä¸€ç¬ç‚¹ç¯ï¼‰å¾Œã€4å›ç›®ã§å®‰å®š
function applyFlickerPreset(){
  const D = duration; // ç·ç§’
  // ãŸã‚ã®é•·ã•: 1å›ç›®é•·ã„ã€2,3çŸ­ã„ã€4å›ç›®ã‚„ã‚„é•·ã„ï¼ˆæ¯”ç‡ï¼‰
  const hold1=0.40*D, hold2=0.18*D, hold3=0.14*D, hold4=0.20*D; // åˆè¨ˆ0.92D
  const flash = 0.02*D; // ä¸€ç¬ç‚¹ç¯ï¼ˆå„0.02Dï¼‰â†’åˆè¨ˆ 0.06D
  const tail = Math.max(0.0, D - (hold1+hold2+hold3+hold4 + 3*flash)); // æ®‹ã‚Šï¼ˆå®‰å®šç«‹ã¡ä¸ŠãŒã‚Šï¼‰

  const keysT = [];
  let t = 0; const push=(time,value)=>keysT.push({time:Math.min(time,D), value});
  const charge = (start, dur, pre, peak)=>{
    // æºœã‚: 0â†’pre ã¸ã‚†ã£ãã‚Šï¼ˆç·šå½¢è¿‘ä¼¼ï¼‰
    push(start, 0.0); push(start + dur*0.9, pre);
    // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥: ä¸€ç¬ peak ã¾ã§ä¸Šã’ã¦ã™ãè½ã¨ã™
    push(start + dur,  peak);
    push(start + dur + flash*0.6, 0.10); // ã™ãæ¶ˆç¯
    return start + dur + flash;
  };
  t = charge(0, hold1, 0.45, 0.92);
  t = charge(t, hold2, 0.55, 0.96);
  t = charge(t, hold3, 0.65, 0.98);
  // 4å›ç›®: ãŸã‚â†’é‹­ã„ç«‹ã¡ä¸ŠãŒã‚Š
  push(t, 0.0); push(t + hold4*0.90, 0.75);
  push(t + hold4, 0.95);
  push(t + hold4 + Math.max(0.05*D, tail*0.15), 1.00); // ã‚ˆã‚ŠçŸ­æ™‚é–“ã§æ€¥æ¿€ã« 1.0
  push(D, 1.00);
  tTrack.setKeys(keysT);

  // Ïƒ: ãŸã‚ä¸­ã¯ã‚„ã‚„ç‹­ã„â†’ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã§åºƒã„â†’å®‰å®šã§ä¸­åº¸
  const keysS = [];
  const pushS=(time,value)=>keysS.push({time:Math.min(time,D), value});
  let s=0;
  const chargeS=(start, dur)=>{
    pushS(start, 0.030); pushS(start + dur*0.9, 0.045); // ãŸã‚ã§ã¡ã‚‡ã„åºƒãŒã‚‹
    pushS(start + dur, 0.080); // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ™‚ã«åºƒã
    pushS(start + dur + flash*0.6, 0.035); // ç›´å¾Œã«æˆ»ã‚‹
    return start + dur + flash;
  };
  s = chargeS(0, hold1);
  s = chargeS(s, hold2);
  s = chargeS(s, hold3);
  // 4å›ç›®: ãŸã‚â†’æ€¥æ¿€ã«åºƒã„â†’å®‰å®šï¼ˆã‚ˆã‚Šåºƒã„ç¯„å›²ã‚’æ´»ç”¨ï¼‰
  pushS(s, 0.035); pushS(s + hold4*0.90, 0.065);
  pushS(s + hold4 + Math.max(0.05*D, tail*0.15), 0.120);
  pushS(D, 0.120);
  sTrack.setKeys(keysS);
}

// ======================= Wiring =======================
const canvas = document.getElementById('lamp');
const ctx = canvas.getContext('2d');
const tSlider = document.getElementById('t');
const sSlider = document.getElementById('sigma');
const peakPosSlider = document.getElementById('peakPos');
const lampLengthSlider = document.getElementById('lampLength');
const tVal = document.getElementById('tVal');
const sVal = document.getElementById('sigmaVal');
const peakPosVal = document.getElementById('peakPosVal');
const lampLengthVal = document.getElementById('lampLengthVal');

const tlT = document.getElementById('timelineT');
const tlS = document.getElementById('timelineS');
const playbackSeqCanvas = document.getElementById('playbackSequence');
const playBtn = document.getElementById('playPause');
const exportBtn = document.getElementById('exportVideo');
const loopChk = document.getElementById('loop');
const durInput = document.getElementById('duration');
const timeVal = document.getElementById('timeVal');

let duration = parseFloat(durInput.value);
let playhead = 0.0;
let playing = false; let lastPerf = 0;

const tTrack = new Track(tlT, {min:0, max:1, label:'t', color:'#7cc9ff', keys:[]});
const sTrack = new Track(tlS, {min:0.005, max:0.50, label:'Ïƒ', color:'#ffd27c', keys:[]});
const playbackSequence = new PlaybackSequence(playbackSeqCanvas);
applyFlickerPreset();

function syncFromTracks(){
  const t = tTrack.valueAt(playhead);
  const s = sTrack.valueAt(playhead);
  tSlider.value = t.toFixed(3); sSlider.value = s.toFixed(3);
  tVal.textContent = (+tSlider.value).toFixed(3);
  
  // Ïƒå€¤è¡¨ç¤ºï¼ˆé•·ã•ã«ã‚ˆã‚‹èª¿æ•´æƒ…å ±ã‚‚å«ã‚€ï¼‰
  const lampLen = +lampLengthSlider.value;
  const sigmaVal = +sSlider.value;
  let lengthFactor = 1.0;
  if (lampLen > 1.5) {
    lengthFactor = Math.max(0.2, 0.8 / lampLen);
  } else if (lampLen > 1.0) {
    lengthFactor = 1.0 - (lampLen - 1.0) * 0.6;
  }
  
  if (lengthFactor < 0.99) {
    sVal.textContent = `${sigmaVal.toFixed(3)} (Ã—${lengthFactor.toFixed(2)})`;
  } else {
    sVal.textContent = sigmaVal.toFixed(3);
  }
  
  peakPosVal.textContent = (+peakPosSlider.value).toFixed(3);
  
  // è›å…‰ç¯ã®é•·ã•è¡¨ç¤ºï¼ˆç¸®å°æƒ…å ±ã‚‚å«ã‚€ï¼‰
  if (lampLen > 1.0) {
    lampLengthVal.textContent = `${lampLen.toFixed(2)} (ç¸®å°)`;
  } else {
    lampLengthVal.textContent = lampLen.toFixed(2);
  }
  
  timeVal.textContent = playhead.toFixed(2);
  drawLamp(ctx, +tSlider.value, +sSlider.value, +peakPosSlider.value, +lampLengthSlider.value);
}

function redrawTimelines(){ 
  tTrack.draw(); 
  sTrack.draw(); 
  playbackSequence.draw(); 
}

// å‹•ç”»å‡ºåŠ›æ©Ÿèƒ½
async function exportVideo(){
  const fps = 60;
  const totalFrames = Math.floor(duration * fps);
  
  exportBtn.textContent = 'ğŸ“¹ å‡ºåŠ›ä¸­...';
  exportBtn.disabled = true;
  
  try {
    // MediaRecorderç”¨ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œæˆ
    const stream = canvas.captureStream(fps);
    const mediaRecorder = new MediaRecorder(stream, {
      mimeType: 'video/webm;codecs=vp9',
      videoBitsPerSecond: 8000000 // 8Mbps
    });
    
    const chunks = [];
    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        chunks.push(event.data);
      }
    };
    
    mediaRecorder.onstop = () => {
      const blob = new Blob(chunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `fluorescent_lamp_${Date.now()}.webm`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      exportBtn.textContent = 'ğŸ“¹ å‹•ç”»å‡ºåŠ›';
      exportBtn.disabled = false;
    };
    
    // éŒ²ç”»é–‹å§‹
    mediaRecorder.start();
    
    // ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«æç”»
    for(let frame = 0; frame < totalFrames; frame++){
      const currentTime = (frame / fps);
      const t = tTrack.valueAt(currentTime);
      const s = sTrack.valueAt(currentTime);
      const peakPos = +peakPosSlider.value;
      const lampLen = +lampLengthSlider.value;
      
      drawLamp(ctx, t, s, peakPos, lampLen);
      
      // é€²æ—è¡¨ç¤º
      if(frame % 30 === 0){
        exportBtn.textContent = `ğŸ“¹ å‡ºåŠ›ä¸­... ${Math.floor((frame/totalFrames)*100)}%`;
      }
      
      // ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã®å¾…æ©Ÿ
      await new Promise(resolve => setTimeout(resolve, 1000/fps));
    }
    
    // éŒ²ç”»åœæ­¢
    setTimeout(() => {
      mediaRecorder.stop();
    }, 100);
    
  } catch (error) {
    console.error('å‹•ç”»å‡ºåŠ›ã‚¨ãƒ©ãƒ¼:', error);
    alert('å‹•ç”»å‡ºåŠ›ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ãŒWebMå‡ºåŠ›ã«å¯¾å¿œã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚');
    exportBtn.textContent = 'ğŸ“¹ å‹•ç”»å‡ºåŠ›';
    exportBtn.disabled = false;
  }
}

function tick(now){
  if(!playing) return; if(!lastPerf) lastPerf = now; const dt = (now - lastPerf)/1000; lastPerf = now;
  playhead += dt; if(playhead > duration){ if(loopChk.checked){ playhead = playhead % duration; } else { playhead = duration; playing=false; playBtn.textContent='â–¶ï¸ å†ç”Ÿ'; } }
  syncFromTracks(); redrawTimelines(); requestAnimationFrame(tick);
}

// Slider manual control (preview)
tSlider.addEventListener('input', ()=>{ playing=false; playBtn.textContent='â–¶ï¸ å†ç”Ÿ'; drawLamp(ctx, +tSlider.value, +sSlider.value, +peakPosSlider.value, +lampLengthSlider.value); tVal.textContent=(+tSlider.value).toFixed(3); });
sSlider.addEventListener('input', ()=>{ 
  playing=false; 
  playBtn.textContent='â–¶ï¸ å†ç”Ÿ'; 
  drawLamp(ctx, +tSlider.value, +sSlider.value, +peakPosSlider.value, +lampLengthSlider.value); 
  
  // Ïƒå€¤è¡¨ç¤ºï¼ˆé•·ã•ã«ã‚ˆã‚‹èª¿æ•´æƒ…å ±ã‚‚å«ã‚€ï¼‰
  const lampLen = +lampLengthSlider.value;
  const sigmaVal = +sSlider.value;
  let lengthFactor = 1.0;
  if (lampLen > 1.5) {
    lengthFactor = Math.max(0.2, 0.8 / lampLen);
  } else if (lampLen > 1.0) {
    lengthFactor = 1.0 - (lampLen - 1.0) * 0.6;
  }
  
  if (lengthFactor < 0.99) {
    sVal.textContent = `${sigmaVal.toFixed(3)} (Ã—${lengthFactor.toFixed(2)})`;
  } else {
    sVal.textContent = sigmaVal.toFixed(3);
  }
});
peakPosSlider.addEventListener('input', ()=>{ playing=false; playBtn.textContent='â–¶ï¸ å†ç”Ÿ'; drawLamp(ctx, +tSlider.value, +sSlider.value, +peakPosSlider.value, +lampLengthSlider.value); peakPosVal.textContent=(+peakPosSlider.value).toFixed(3); });
lampLengthSlider.addEventListener('input', ()=>{ 
  playing=false; 
  playBtn.textContent='â–¶ï¸ å†ç”Ÿ'; 
  drawLamp(ctx, +tSlider.value, +sSlider.value, +peakPosSlider.value, +lampLengthSlider.value); 
  
  // é•·ã•æƒ…å ±ã‚’è¡¨ç¤º
  const lampLen = +lampLengthSlider.value;
  if (lampLen > 1.0) {
    lampLengthVal.textContent = `${lampLen.toFixed(2)} (ç¸®å°)`;
  } else {
    lampLengthVal.textContent = lampLen.toFixed(2);
  }
  
  // Ïƒå€¤è¡¨ç¤ºã‚‚æ›´æ–°ï¼ˆé•·ã•ä¿‚æ•°ãŒå¤‰ã‚ã‚‹ãŸã‚ï¼‰
  const sigmaVal = +sSlider.value;
  let lengthFactor = 1.0;
  if (lampLen > 1.5) {
    lengthFactor = Math.max(0.2, 0.8 / lampLen);
  } else if (lampLen > 1.0) {
    lengthFactor = 1.0 - (lampLen - 1.0) * 0.6;
  }
  
  if (lengthFactor < 0.99) {
    sVal.textContent = `${sigmaVal.toFixed(3)} (Ã—${lengthFactor.toFixed(2)})`;
  } else {
    sVal.textContent = sigmaVal.toFixed(3);
  }
});

// Playback controls
playBtn.addEventListener('click', ()=>{
  // æœ€å¾Œã«ã„ã‚‹å ´åˆã¯æœ€åˆã‹ã‚‰å†ç”Ÿ
  if(playhead >= duration && !playing) {
    playhead = 0;
  }
  playing = !playing; 
  playBtn.textContent = playing ? 'â¸ ä¸€æ™‚åœæ­¢' : 'â–¶ï¸ å†ç”Ÿ'; 
  lastPerf = 0; 
  if(playing) requestAnimationFrame(tick);
});

exportBtn.addEventListener('click', exportVideo);
durInput.addEventListener('change', ()=>{
  duration = Math.max(0.5, Math.min(30, parseFloat(durInput.value)||4)); durInput.value = duration.toFixed(1);
  // æœ«å°¾ã‚­ãƒ¼ã‚’æ–°ã—ã„é•·ã•ã¸åˆã‚ã›ã‚‹ï¼ˆå…ˆé ­ã¨æœ«å°¾ãŒå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
  if(tTrack.keys.length>=2){ tTrack.keys[tTrack.keys.length-1].time = duration; }
  if(sTrack.keys.length>=2){ sTrack.keys[sTrack.keys.length-1].time = duration; }
  playhead = Math.min(playhead, duration); syncFromTracks(); redrawTimelines();
});

// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆ
document.addEventListener('keydown', (e) => {
  if(e.code === 'Space' && !e.repeat) {
    e.preventDefault();
    // æœ€å¾Œã«ã„ã‚‹å ´åˆã¯æœ€åˆã‹ã‚‰å†ç”Ÿ
    if(playhead >= duration && !playing) {
      playhead = 0;
    }
    playing = !playing; 
    playBtn.textContent = playing ? 'â¸ ä¸€æ™‚åœæ­¢' : 'â–¶ï¸ å†ç”Ÿ'; 
    lastPerf = 0; 
    if(playing) requestAnimationFrame(tick);
  } else if(e.code === 'Backspace' || e.code === 'Delete') {
    // é¸æŠã•ã‚ŒãŸç‚¹ã‚’å‰Šé™¤
    let deleted = false;
    deleted = tTrack.deleteSelectedPoints() || deleted;
    deleted = sTrack.deleteSelectedPoints() || deleted;
    
    if(deleted) {
      e.preventDefault(); // ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’é˜²ã
    }
  } else if(e.code === 'Escape') {
    // é¸æŠã‚’è§£é™¤
    let cleared = false;
    cleared = tTrack.clearSelection() || cleared;
    cleared = sTrack.clearSelection() || cleared;
    
    if(cleared) {
      e.preventDefault(); // ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œã‚’é˜²ã
    }
  }
});

// åˆæœŸæç”»
syncFromTracks(); redrawTimelines();
</script>
</body>
</html>
