<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>è›å…‰ç¯ ç‚¹ç¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ï¼ˆv7: ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ å†ç”Ÿï¼‰</title>
<style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: #000;
      color: #e5e5e5;
      font-family: ui-sans-serif, -apple-system, system-ui, "Noto Sans JP", Roboto, Arial, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      display: grid;
      place-items: start center;
      padding: 20px;
    }
    .wrap { 
      width: min(1100px, calc(100vw - 40px)); 
      max-width: 100%;
    }
    h1 { 
      font-size: 20px; 
      margin: 0 0 20px; 
      font-weight: 600; 
      color: #f0f0f0; 
      text-align: center;
    }
    h2 { 
      font-size: 14px; 
      margin: 0 0 12px; 
      color: #eaeaea; 
      font-weight: 600; 
    }
    .panel {
      border: 1px solid #222;
      background: linear-gradient(#0c0c0c, #050505);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 6px 24px rgba(0,0,0,.5), inset 0 1px 0 rgba(255,255,255,.02);
      overflow: hidden;
    }
    .row { 
      display: flex; 
      align-items: center; 
      gap: 12px; 
      flex-wrap: wrap; 
      margin-bottom: 12px;
    }
    .row:last-child {
      margin-bottom: 0;
    }
    label { 
      font-size: 14px; 
      color: #cfcfcf; 
      white-space: nowrap;
    }
    input[type="range"] { 
      width: clamp(200px, 35vw, 400px); 
      accent-color: #9ae6b4; 
    }
    .value { 
      font-variant-numeric: tabular-nums; 
      min-width: 3ch; 
      text-align: right; 
      color: #fff; 
      font-weight: 500;
    }
    canvas { 
      display: block; 
      width: 100%; 
      border-radius: 8px; 
      margin-bottom: 8px;
    }
    canvas:last-child {
      margin-bottom: 0;
    }
    .axis { 
      margin-top: 8px; 
      font-size: 12px; 
      color: #aaa; 
      line-height: 1.4;
    }
    #curve { cursor: default; pointer-events: none; }
    button { 
      background:#1c1c1c; 
      color:#e7e7e7; 
      border:1px solid #333; 
      border-radius:8px; 
      padding:8px 12px; 
      cursor:pointer; 
      font-size: 13px;
      transition: all 0.2s ease;
    }
    button:hover { 
      filter: brightness(1.1); 
      border-color: #555;
    }
    input[type="number"] { 
      width: 6.5em; 
      background:#0d0d0d; 
      color:#eee; 
      border:1px solid #333; 
      border-radius:6px; 
      padding:6px 8px; 
      font-size: 13px;
    }
    input[type="checkbox"] {
      accent-color: #9ae6b4;
      transform: scale(1.1);
    }
</style>
</head>
<body>
  <div class="wrap">
    <h1>è›å…‰ç¯ ç‚¹ç¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿</h1>
    
    <!-- ä¸Šéƒ¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼šã‚«ãƒ©ãƒ¼ãƒãƒ¼ -->
    <div class="panel" style="margin-bottom: 16px;">
      <h2 style="font-size:14px;margin:0 0 12px;color:#eaeaea;font-weight:600">ã‚«ãƒ©ãƒ¼ãƒãƒ¼</h2>

      <!-- ã‚«ãƒ©ãƒ¼ãƒãƒ¼ï¼ˆåŸºç¤é–¢æ•°ã®å¯è¦–åŒ–ï¼‰ -->
      <canvas id="bar" height="120" aria-label="ã‚«ãƒ©ãƒ¼ãƒãƒ¼"></canvas>
      <canvas id="axis" height="36" class="axis" aria-hidden="true"></canvas>
      </div>
      
    <!-- ä¸­å¤®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼šè›å…‰ç¯ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
    <div class="panel" style="margin-bottom: 16px;">
      <h2 style="font-size:14px;margin:0 0 12px;color:#eaeaea;font-weight:600">è›å…‰ç¯ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h2>
      <canvas id="lamp" height="140" aria-label="è›å…‰ç¯ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼"></canvas>
      <canvas id="lampAxis" height="36" class="axis" aria-hidden="true"></canvas>
    </div>

    <!-- ä¸‹éƒ¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼šå†ç”Ÿã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¨è‰²æ¸©åº¦ã‚«ãƒ¼ãƒ– -->
    <div class="panel">
      <!-- å†ç”Ÿ & ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ -->
      <h2 style="font-size:14px;margin:0 0 12px;color:#eaeaea;font-weight:600">å†ç”Ÿã‚·ãƒ¼ã‚±ãƒ³ã‚¹</h2>
      
      <!-- å†ç”Ÿåˆ¶å¾¡ -->
      <div class="row" style="gap:10px; margin-bottom:12px">
        <button id="playBtn" title="ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ã‚‚å†ç”Ÿ/åœæ­¢">â–¶ å†ç”Ÿ</button>
        <button id="genBtn" title="å†…éƒ¨ã§JSONã‚’ç”Ÿæˆã—ã¦èª­ã¿è¾¼ã¿">ğŸ§ª JSONç”Ÿæˆâ†’èª­è¾¼</button>
        <span class="value" id="timeVal">0.00s</span>
        <label for="duration">é•·ã•(s)</label>
        <input id="duration" type="number" min="0.1" step="0.1" value="2.0" />
        <label style="display:flex;align-items:center;gap:6px"><input id="loop" type="checkbox" /> ãƒ«ãƒ¼ãƒ—</label>
      </div>
      
      
      
      <canvas id="timeline" height="64" aria-label="ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³"></canvas>
      <div class="axis" aria-hidden="true" style="margin-top:6px">å†ç”Ÿãƒ˜ãƒƒãƒ‰ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹• / ç©ºç™½éƒ¨ã‚¯ãƒªãƒƒã‚¯ã§å†ç”Ÿãƒ˜ãƒƒãƒ‰ç§»å‹• / å·¦å³çŸ¢å°ã‚­ãƒ¼ã§0.01ç§’ç§»å‹• / ã‚·ãƒ•ãƒˆ+å·¦å³çŸ¢å°ã‚­ãƒ¼ã§0.1ç§’ç§»å‹•</div>

      <!-- æ›²ç·šã‚¨ãƒ‡ã‚£ã‚¿ï¼ˆå·¦å³å¯¾ç§°ã€‚ç·¨é›†ã¯å·¦åŠåˆ†ã®ã¿ï¼‰ -->
      <h2 style="font-size:14px;margin:24px 0 12px;color:#eaeaea;font-weight:600">è‰²æ¸©åº¦ã‚«ãƒ¼ãƒ–ï¼ˆè¡¨ç¤ºã®ã¿ï¼‰</h2>
      <canvas id="curve" height="200" aria-label="è‰²æ¸©åº¦ã‚«ãƒ¼ãƒ–ã‚¨ãƒ‡ã‚£ã‚¿"></canvas>
      <div class="axis" aria-hidden="true" style="margin-top:6px">x: 0 â†’ 1ï¼ˆãƒ©ãƒ³ãƒ—å·¦â†’å³ï¼‰ / y: 0ï¼ˆæš—ï¼‰â†’ 1ï¼ˆç™½ï¼‰
        ãƒ»è¡¨ç¤ºå°‚ç”¨ã€‚JSONã‚’ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã¸ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã§èª­ã¿è¾¼ã¿å¯èƒ½ã€‚
        ãƒ»å¸¸ã«ç¾åœ¨ã®å†ç”Ÿãƒ˜ãƒƒãƒ‰ä½ç½®ã®è‰²æ¸©åº¦ã‚«ãƒ¼ãƒ–ã‚’è¡¨ç¤ºï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ï¼‰
      </div>
    </div>
    </div>

<script>
    // ===== Math helpers =====
    const clamp = (x, lo, hi) => Math.min(hi, Math.max(lo, x));
    const lerp  = (a, b, t)   => a + (b - a) * t;
    function smoothstep(edge0, edge1, x){
      const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
      return t * t * (3 - 2 * t);
    }

    function deepCopyPoints(arr){ return arr.map(p=>({id:p.id, x:p.x, y:p.y})); }



    // ä¸€è²«ã—ãŸå·¦å³ä½™ç™½ï¼ˆå·¦=å³ï¼‰
    function getMargins(dpr){
      return { l: Math.floor(42*dpr), r: Math.floor(42*dpr), t: Math.floor(12*dpr), b: Math.floor(24*dpr) };
    }

    // ===== Color Temperature functionï¼ˆæŒ‡å®šå®Ÿè£…ï¼‰ =====
    function colorTemperature(t) {
      const phase1 = smoothstep(0.0, 0.3, t); // é»’ã£ã½ã„ã‚°ãƒ¬ãƒ¼â†’æš—ã„èµ¤
      const phase2 = smoothstep(0.3, 0.6, t); // æš—ã„èµ¤â†’ã‚ªãƒ¬ãƒ³ã‚¸
      const phase3 = smoothstep(0.6, 0.8, t); // ã‚ªãƒ¬ãƒ³ã‚¸â†’é»„è‰²
      const phase4 = smoothstep(0.8, 1.0, t); // é»„è‰²â†’ç™½
      
      // é»’ã£ã½ã„ã‚°ãƒ¬ãƒ¼(30,30,30) â†’ æš—ã„èµ¤(80,20,20) â†’ ã‚ªãƒ¬ãƒ³ã‚¸(255,120,0) â†’ é»„è‰²(255,255,0) â†’ ç™½(255,255,255)
      const red   = lerp(30, 80, phase1) + lerp(0, 175, phase2) + lerp(0, 0, phase3) + lerp(0, 0, phase4);
      const green = lerp(30, 20, phase1) + lerp(0, 100, phase2) + lerp(0, 135, phase3) + lerp(0, 255, phase4);
      const blue  = lerp(30, 20, phase1) + lerp(0, 0, phase2) + lerp(0, 0, phase3) + lerp(0, 255, phase4);
      
      // ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã¯å¸¸ã«1.0ï¼ˆé€æ˜ãªã—ï¼‰
      return [red, green, blue, 1.0];
    }

    // ===== Elements =====
    const bar = document.getElementById('bar');
    const axis = document.getElementById('axis');
    const lamp = document.getElementById('lamp');
    const lampAxis = document.getElementById('lampAxis');
    const curve = document.getElementById('curve');
    const timeline = document.getElementById('timeline');

    
    const panel = document.querySelector('.panel');



    const playBtn = document.getElementById('playBtn');
    const genBtn = document.getElementById('genBtn');
    const timeSlider = document.getElementById('timeSlider');
    const timeVal = document.getElementById('timeVal');
    const durationInput = document.getElementById('duration');
    const loopChk = document.getElementById('loop');
    

    // ===== Curve modelï¼ˆå·¦åŠåˆ†ã®ã¿ï¼š0..0.5 â†’ 0..1ï¼‰ =====
    let points = [ { id: 1, x: 0.0, y: 0.0 }, { id: 2, x: 0.5, y: 0.0 } ];
    let nextPointId = 3;
    function sortPoints(P){ P.sort((a,b)=>a.x-b.x); }

    function evalHalfWithPoints(P, s){
      s = clamp(s, 0, 0.5);
      if (!P || P.length === 0) return 0;
      if (P.length === 1) return clamp(P[0].y, 0, 1);
      const PP = P.map(p=>({x:p.x/0.5, y:p.y})).slice().sort((a,b)=>a.x-b.x);
      const u = (s / 0.5);
      let i = 0; while (i < PP.length - 1 && u > PP[i+1].x) i++; i = Math.max(0, Math.min(i, PP.length - 2));
      const p0 = PP[Math.max(0, i-1)], p1 = PP[i], p2 = PP[i+1], p3 = PP[Math.min(PP.length-1, i+2)];
      const span = (p2.x - p1.x) || 1e-6; const t = (u - p1.x) / span;
      const y0=p0.y,y1=p1.y,y2=p2.y,y3=p3.y;
      const a0 = -0.5*y0 + 1.5*y1 - 1.5*y2 + 0.5*y3;
      const a1 =  y0    - 2.5*y1 + 2.0*y2 - 0.5*y3;
      const a2 = -0.5*y0 + 0.5*y2;
      const a3 =  y1;
      const y = ((a0*t + a1)*t + a2)*t + a3;
      return clamp(y, 0, 1);
    }
    function evalHalf(s){ return evalHalfWithPoints(points, s); }
    function curveYEditor(x){ const s = x <= 0.5 ? x : 1 - x; return evalHalf(s); }

    // LUTï¼ˆå·¦åŠåˆ†ã®ã¿ï¼‰
    const N_SAMPLES = 256;
    function makeLUT(P){
      const lut = new Float32Array(N_SAMPLES);
      for (let i=0;i<N_SAMPLES;i++){
        const s = (i/(N_SAMPLES-1))*0.5; // å·¦åŠåˆ†ã®è·é›¢
        lut[i] = evalHalfWithPoints(P, s);
      }
      return lut;
    }
    function sampleLUT(lut, s){ // s: 0..0.5
      const u = clamp(s / 0.5, 0, 1) * (N_SAMPLES-1);
      const i0 = Math.floor(u), i1 = Math.min(N_SAMPLES-1, i0+1);
      const a = u - i0;
      return lerp(lut[i0], lut[i1], a);
    }

    // ===== Timeline / Keyframes =====
    let duration = 2.0; // seconds
    let time = 0.0;
    let playing = false;
    let lastTS = 0;
    let loopPlay = true;

    let keyframes = [];
    let nextKFId = 1;
    let selectedKF = 0; // index
    function initDefaultKeyframes(){
      keyframes = [];
      keyframes.push({ id: nextKFId++, t: 0.0, points: deepCopyPoints(points), lut: makeLUT(points) });
      keyframes.push({ id: nextKFId++, t: duration, points: deepCopyPoints(points), lut: makeLUT(points) });
      selectedKF = 0;
      time = 0; syncTimeUI();
    }

    function sortKeyframes(){ keyframes.sort((a,b)=>a.t-b.t); }

    function findSpan(t){
      sortKeyframes();
      if (t <= keyframes[0].t) return { a: keyframes[0], b: keyframes[0], alpha: 0 };
      if (t >= keyframes[keyframes.length-1].t) return { a: keyframes[keyframes.length-1], b: keyframes[keyframes.length-1], alpha: 0 };
      for (let i=0;i<keyframes.length-1;i++){
        const A = keyframes[i], B = keyframes[i+1];
        if (t >= A.t && t <= B.t){
          const alpha = (t - A.t) / Math.max(1e-6, (B.t - A.t));
          return { a: A, b: B, alpha };
        }
      }
      return { a: keyframes[0], b: keyframes[0], alpha: 0 };
    }

    // ç¾åœ¨ã®æ™‚é–“ä½ç½®ã«ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    function hasKeyframeAtCurrentTime(){
      return keyframes.some(kf => Math.abs(kf.t - time) < 0.001);
    }

    // ç¾åœ¨ã®æ™‚é–“ä½ç½®ã«ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãŒå­˜åœ¨ã—ãªã„å ´åˆã€è‡ªå‹•çš„ã«ä½œæˆ
    function ensureKeyframeAtCurrentTime(){
      if (!hasKeyframeAtCurrentTime()) {
        // ç¾åœ¨ã®å†ç”Ÿãƒ˜ãƒƒãƒ‰ã®ä½ç½®ã®è£œå®Œã•ã‚ŒãŸç‚¹ã®ä½ç½®ã‹ã‚‰ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½œæˆ
        const currentCurvePoints = getCurrentPlaybackPoints();
        const kf = { 
          id: nextKFId++, 
          t: time, 
          points: deepCopyPoints(currentCurvePoints), 
          lut: makeLUT(currentCurvePoints) 
        };
        keyframes.push(kf); 
        sortKeyframes();
        // æ–°ã—ãä½œæˆã•ã‚ŒãŸã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é¸æŠ
        const idx = keyframes.findIndex(x=>x.id===kf.id);
        selectedKF = idx;
      }
    }

    // ä»»æ„ã®å†ç”Ÿä½ç½®ã®æ™‚é–“è£œå®Œã•ã‚ŒãŸç‚¹ã®ä½ç½®ã‚’å–å¾—ã™ã‚‹é–¢æ•°ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
    function getPlaybackPointsAtTime(targetTime){
      if (keyframes.length === 0) return [];
      if (keyframes.length === 1) return deepCopyPoints(keyframes[0].points);
      
      const { a, b, alpha } = findSpan(targetTime);
      if (a.id === b.id) return deepCopyPoints(a.points);
      
      // 2ã¤ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã§åˆ¶å¾¡ç‚¹ã‚’è£œé–“
      const result = [];
      const aPoints = a.points;
      const bPoints = b.points;
      
      // ã‚ˆã‚Šé©åˆ‡ãªè£œé–“å‡¦ç†ï¼šæ›²ç·šã®å½¢çŠ¶ã‚’ä¿ã¤
      if (aPoints.length === 0 && bPoints.length > 0) {
  // aã«åˆ¶å¾¡ç‚¹ãŒãªã„å ´åˆã§ã‚‚ã€ç¾åœ¨æ™‚åˆ»ã®æ›²ç·šã‹ã‚‰yã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ã¦è¿”ã™
  return bPoints.map(p => ({ id: p.id, x: p.x, y: getCurveValueAtTime(targetTime, p.x) }));
}
 else if (aPoints.length > 0 && bPoints.length === 0) {
        // bã«åˆ¶å¾¡ç‚¹ãŒãªã„å ´åˆã€aã®åˆ¶å¾¡ç‚¹ã‚’ãã®ã¾ã¾ä½¿ç”¨
        return deepCopyPoints(aPoints);
      } else if (aPoints.length === 0 && bPoints.length === 0) {
        // ä¸¡æ–¹ã«åˆ¶å¾¡ç‚¹ãŒãªã„å ´åˆã€ç©ºã®é…åˆ—ã‚’è¿”ã™
        return [];
      }
      
      // ä¸¡æ–¹ã«åˆ¶å¾¡ç‚¹ãŒã‚ã‚‹å ´åˆã€å˜ç´”ãªç·šå½¢è£œå®Œ
      // åˆ¶å¾¡ç‚¹ã®æ•°ãŒç•°ãªã‚‹å ´åˆã€ã™ã¹ã¦ã®åˆ¶å¾¡ç‚¹ã‚’è¡¨ç¤º
      const allIds = new Set([...aPoints.map(p => p.id), ...bPoints.map(p => p.id)]);
      
      for (const id of allIds) {
        const aPoint = aPoints.find(p => p.id === id);
        const bPoint = bPoints.find(p => p.id === id);
        
        if (aPoint && bPoint) {
          // ä¸¡æ–¹ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã«å­˜åœ¨ã™ã‚‹å ´åˆã€ç·šå½¢è£œå®Œ
          result.push({
            id: id,
            x: lerp(aPoint.x, bPoint.x, alpha),
            y: lerp(aPoint.y, bPoint.y, alpha)
          });
        } else if (aPoint) {
                // aã®ã¿ã«å­˜åœ¨ã™ã‚‹å ´åˆã€ç¾åœ¨æ™‚åˆ»ã®æ›²ç·šã‹ã‚‰yã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
      result.push({ id: id, x: aPoint.x, y: getCurveValueAtTime(targetTime, aPoint.x) });
} else if (bPoint) {
                // bã®ã¿ã«å­˜åœ¨ã™ã‚‹å ´åˆã€ç¾åœ¨æ™‚åˆ»ã®æ›²ç·šã‹ã‚‰yã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
      result.push({ id: id, x: bPoint.x, y: getCurveValueAtTime(targetTime, bPoint.x) });
}
      }
      
      sortPoints(result);
      return result;
    }

    // ç¾åœ¨ã®å†ç”Ÿãƒ˜ãƒƒãƒ‰ã®ä½ç½®ã®æ™‚é–“è£œå®Œã•ã‚ŒãŸç‚¹ã®ä½ç½®ã‚’å–å¾—
    function getCurrentPlaybackPoints(){
      return getPlaybackPointsAtTime(time);
    }

    // æ™‚é–“è£œå®Œã•ã‚ŒãŸæ›²ç·šã®å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•°ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
    function getCurveValueAtTime(targetTime, x){
      const s = x <= 0.5 ? x : 1 - x;
      if (keyframes.length === 0) return 0;
      if (keyframes.length === 1) return sampleLUT(keyframes[0].lut, s);
      
      const { a, b, alpha } = findSpan(targetTime);
      if (a.id === b.id) return sampleLUT(a.lut, s);
      
      const ya = sampleLUT(a.lut, s);
      const yb = sampleLUT(b.lut, s);
      return lerp(ya, yb, alpha);
    }

    // ç¾åœ¨ã®å†ç”Ÿãƒ˜ãƒƒãƒ‰ä½ç½®ã§ã®æ›²ç·šã®å€¤ã‚’å–å¾—
    function getCurrentCurveValue(x){
      return getCurveValueAtTime(time, x);
    }

    // æ—¢å­˜ã®é–¢æ•°ã‚’æ–°ã—ã„é–¢æ•°ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«æ›´æ–°
    function curveYPlayback(x){
      return getCurrentCurveValue(x);
    }

    function updateSelectedKFPointsFromEditor(){
      if (keyframes.length === 0) return;
      // ç¾åœ¨ã®æ™‚é–“ä½ç½®ã«ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãŒå­˜åœ¨ã—ãªã„å ´åˆã€è‡ªå‹•çš„ã«ä½œæˆ
      ensureKeyframeAtCurrentTime();
      // è‡ªå‹•ä½œæˆã•ã‚ŒãŸå ´åˆã¯ã€æ–°ã—ãä½œæˆã•ã‚ŒãŸã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é¸æŠ
      if (selectedKF >= keyframes.length) {
        selectedKF = keyframes.length - 1;
      }
      // é¸æŠã•ã‚ŒãŸã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ›´æ–°ï¼ˆç·¨é›†ã•ã‚ŒãŸåˆ¶å¾¡ç‚¹ã‚’ä½¿ç”¨ï¼‰
      const kf = keyframes[selectedKF];
      kf.points = deepCopyPoints(points);
      kf.lut = makeLUT(points);
    }

    function selectKFByIndex(idx){
      selectedKF = clamp(idx, 0, keyframes.length-1)|0;
      // ç·¨é›†ç”¨ points ã‚’ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®çŠ¶æ…‹ã«åŒæœŸ
      const src = keyframes[selectedKF].points;
      points = deepCopyPoints(src);
      nextPointId = points.reduce((m,p)=>Math.max(m,p.id),0) + 1;
          render();
        }

    // ç¾åœ¨ã®å†ç”Ÿãƒ˜ãƒƒãƒ‰ä½ç½®ã®åˆ¶å¾¡ç‚¹ã‚’ç·¨é›†ç”¨ã®pointsã«åæ˜ 
    function syncEditorPointsToCurrentTime(){
      if (keyframes.length === 0) return;
      
      // ç¾åœ¨ã®æ™‚é–“ä½ç½®ã«ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãŒå­˜åœ¨ã™ã‚‹å ´åˆ
      if (hasKeyframeAtCurrentTime()) {
        const currentKF = keyframes.find(kf => Math.abs(kf.t - time) < 0.001);
        if (currentKF) {
          points = deepCopyPoints(currentKF.points);
          nextPointId = points.reduce((m,p)=>Math.max(m,p.id),0) + 1;
        }
      } else {
        // ç¾åœ¨ã®æ™‚é–“ä½ç½®ã«ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãŒå­˜åœ¨ã—ãªã„å ´åˆã€è£œé–“ã•ã‚ŒãŸåˆ¶å¾¡ç‚¹ã‚’è¡¨ç¤º
        const currentPoints = getCurrentPlaybackPoints();
        points = deepCopyPoints(currentPoints);
        nextPointId = points.reduce((m,p)=>Math.max(m,p.id),0) + 1;
      }
    }

    function addKeyframeAt(t){
      // æŒ‡å®šã•ã‚ŒãŸæ™‚é–“ä½ç½®ã®è£œå®Œã•ã‚ŒãŸç‚¹ã®ä½ç½®ã‹ã‚‰ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ä½œæˆ
      const currentCurvePoints = getPlaybackPointsAtTime(t);
      const kf = { 
        id: nextKFId++, 
        t: clamp(t, 0, duration), 
        points: deepCopyPoints(currentCurvePoints), 
        lut: makeLUT(currentCurvePoints) 
      };
      keyframes.push(kf); sortKeyframes();
      const idx = keyframes.findIndex(x=>x.id===kf.id);
      selectKFByIndex(idx);
      time = kf.t; syncTimeUI();
    }

    function deleteSelectedKF(){
      if (keyframes.length <= 2) return; // 2å€‹æœªæº€ã«ã—ãªã„
      const id = keyframes[selectedKF].id;
      keyframes = keyframes.filter(k=>k.id!==id);
      selectKFByIndex(Math.max(0, selectedKF-1));
    }

    // å‰ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é¸æŠï¼ˆç¾åœ¨ã®å†ç”Ÿãƒ˜ãƒƒãƒ‰ã®ä½ç½®ã‹ã‚‰è¦‹ã¦ï¼‰
    function selectPreviousKeyframe(){
      if (keyframes.length <= 1) return;
      
      // ç¾åœ¨ã®å†ç”Ÿãƒ˜ãƒƒãƒ‰ã®ä½ç½®ã‹ã‚‰è¦‹ã¦ã€ä¸€ã¤å‰ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ¢ã™
      let prevKF = null;
      for (let i = keyframes.length - 1; i >= 0; i--) {
        if (keyframes[i].t < time) {
          prevKF = keyframes[i];
          break;
        }
      }
      
      // å‰ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯æœ€å¾Œã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ 
      if (!prevKF) {
        prevKF = keyframes[keyframes.length - 1];
      }
      
      // ãã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é¸æŠã—ã€å†ç”Ÿãƒ˜ãƒƒãƒ‰ã‚‚ç§»å‹•
      const idx = keyframes.findIndex(kf => kf.id === prevKF.id);
      selectKFByIndex(idx);
      time = prevKF.t;
      syncTimeUI();
      renderCurve(getCssWidth());
    }

    // æ¬¡ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é¸æŠï¼ˆç¾åœ¨ã®å†ç”Ÿãƒ˜ãƒƒãƒ‰ã®ä½ç½®ã‹ã‚‰è¦‹ã¦ï¼‰
    function selectNextKeyframe(){
      if (keyframes.length <= 1) return;
      
      // ç¾åœ¨ã®å†ç”Ÿãƒ˜ãƒƒãƒ‰ã®ä½ç½®ã‹ã‚‰è¦‹ã¦ã€ä¸€ã¤æ¬¡ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’æ¢ã™
      let nextKF = null;
      for (let i = 0; i < keyframes.length; i++) {
        if (keyframes[i].t > time) {
          nextKF = keyframes[i];
          break;
        }
      }
      
      // æ¬¡ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯æœ€åˆã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ 
      if (!nextKF) {
        nextKF = keyframes[0];
      }
      
      // ãã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é¸æŠã—ã€å†ç”Ÿãƒ˜ãƒƒãƒ‰ã‚‚ç§»å‹•
      const idx = keyframes.findIndex(kf => kf.id === nextKF.id);
      selectKFByIndex(idx);
      time = nextKF.t;
      syncTimeUI();
      renderCurve(getCssWidth());
    }

    // ===== Canvas sizing helpers =====
    function resizeCanvasToCss(canvas, cssW, cssH){
      const dpr = window.devicePixelRatio || 1;
      canvas.width  = Math.max(1, Math.floor(cssW * dpr));
      canvas.height = Math.max(1, Math.floor(cssH * dpr));
      canvas.style.width  = cssW + 'px';
      canvas.style.height = cssH + 'px';
      return dpr;
    }
    function getCssWidth(){ return Math.floor(panel.clientWidth); }

    // ===== Render: bar & axis =====
    function renderBar(cssW){
      const dpr = resizeCanvasToCss(bar, cssW, 120);
      const ctx = bar.getContext('2d');
      const w = bar.width, h = bar.height;
      const img = ctx.createImageData(w, h);
      const data = img.data;
      for (let x = 0; x < w; x++) {
        const t = x / (w - 1);
        const [r0, g0, b0, a0] = colorTemperature(t);
        const r  = Math.round(clamp(r0, 0, 255));
        const g  = Math.round(clamp(g0, 0, 255));
        const bb = Math.round(clamp(b0, 0, 255));
        const a  = Math.round(clamp(a0 * 255, 0, 255));
        for (let y = 0; y < h; y++) {
          const idx = (y * w + x) * 4;
          data[idx+0]=r; data[idx+1]=g; data[idx+2]=bb; data[idx+3]=a;
        }
      }
      ctx.putImageData(img, 0, 0);
    }

    function renderAxis(cssW){
      const dpr = resizeCanvasToCss(axis, cssW, 36);
      const ctx = axis.getContext('2d');
      const wCSS = cssW, hCSS = 36;
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.clearRect(0,0,wCSS,hCSS);
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,wCSS,hCSS);
      ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0.5,0.5); ctx.lineTo((wCSS-1)+0.5, 0.5); ctx.stroke();
      ctx.fillStyle = '#aaa'; ctx.textAlign='center'; ctx.textBaseline='top'; ctx.font='12px ui-sans-serif,system-ui,-apple-system';
      const wMinus1 = wCSS - 1;
      for (let i=0;i<=10;i++){
        const t=i/10; const x=Math.round(t*wMinus1)+0.5; const major=i%2===0;
        ctx.strokeStyle=major?'#777':'#444'; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x, major?12:8); ctx.stroke();
        if(major){ ctx.fillStyle='#cfcfcf'; ctx.fillText(t.toFixed(1), x, 14); }
      }
    }

    // ===== Render: lamp =====
    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
        ctx.beginPath(); 
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y,   x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x,   y+h, rr);
      ctx.arcTo(x,   y+h, x,   y,   rr);
      ctx.arcTo(x,   y,   x+w, y,   rr);
      ctx.closePath();
    }

    function renderLamp(cssW){
      const dpr = resizeCanvasToCss(lamp, cssW, 140);
      const ctx = lamp.getContext('2d');
      const w = lamp.width, h = lamp.height;
      ctx.clearRect(0,0,w,h);

      ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);

      const M = getMargins(dpr);
      const rx = M.l, ry = Math.floor(14*dpr);
      const rw = w - M.l - M.r; const rh = h - ry*2;

      // å›ºå®šã‚µã‚¤ã‚ºã§è›å…‰ç¯ã‚’æç”»
      const adjustedWidth = rw;
      const adjustedHeight = rh;
      const adjustedX = rx;
      const adjustedY = ry;

      // ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã§æç”»
      const off = document.createElement('canvas');
      off.width = adjustedWidth; off.height = adjustedHeight;
      const octx = off.getContext('2d');
      const inner = octx.createImageData(adjustedWidth, adjustedHeight);
      const data = inner.data;

      for (let x = 0; x < adjustedWidth; x++) {
        const xNorm = x / (adjustedWidth - 1); // 0..1 å·¦â†’å³
        // æ™‚é–“è£œå®Œã•ã‚ŒãŸå€¤ã‚’ä½¿ç”¨ï¼ˆå†ç”Ÿä¸­ã§ãªãã¦ã‚‚ï¼‰
        const tt = getCurrentCurveValue(xNorm);
        const [r0,g0,b0,a0] = colorTemperature(tt);
        const r = Math.round(clamp(r0, 0, 255));
        const g = Math.round(clamp(g0, 0, 255));
        const b = Math.round(clamp(b0, 0, 255));
        const a = Math.round(clamp(a0 * 255, 0, 255));
        for (let y = 0; y < adjustedHeight; y++){
          const idx = (y * adjustedWidth + x) * 4;
          data[idx+0]=r; data[idx+1]=g; data[idx+2]=b; data[idx+3]=a;
        }
      }
      octx.putImageData(inner, 0, 0);

      // è§’ä¸¸ï¼†æ ç·šãªã—
      ctx.save();
      roundRect(ctx, adjustedX, adjustedY, adjustedWidth, adjustedHeight, Math.floor(10*dpr));
      ctx.clip();
      ctx.drawImage(off, adjustedX, adjustedY);
      ctx.restore();
    }

    function renderLampAxis(cssW){
      const dpr = resizeCanvasToCss(lampAxis, cssW, 36);
      const ctx = lampAxis.getContext('2d');
      const wCSS = cssW, hCSS = 36;
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.clearRect(0,0,wCSS,hCSS);
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,wCSS,hCSS);
      const M = getMargins(dpr);
      
      // å›ºå®šã‚µã‚¤ã‚ºã§è»¸ã‚’æç”»
      const rw = wCSS - M.l - M.r;
      const adjustedWidth = rw;
      const adjustedX = M.l;
      
      ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(adjustedX+0.5, 0); ctx.lineTo(adjustedX+0.5, hCSS); ctx.stroke();
      ctx.beginPath(); ctx.moveTo((adjustedX+adjustedWidth)-0.5, 0); ctx.lineTo((adjustedX+adjustedWidth)-0.5, hCSS); ctx.stroke();
      
      const innerW = adjustedWidth; const x0 = adjustedX;
      ctx.strokeStyle = '#333'; ctx.beginPath(); ctx.moveTo(0.5, 0.5); ctx.lineTo(wCSS-0.5, 0.5); ctx.stroke();
      ctx.fillStyle = '#aaa'; ctx.textAlign='center'; ctx.textBaseline='top'; ctx.font='12px ui-sans-serif,system-ui,-apple-system';
      for (let i=0;i<=10;i++){
        const t = i/10; const x = Math.round(x0 + t*(innerW-1)) + 0.5; const major=i%2===0;
        ctx.strokeStyle=major?'#777':'#444'; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x, major?12:8); ctx.stroke();
        if(major){ ctx.fillStyle='#cfcfcf'; ctx.fillText(t.toFixed(1), x, 14); }
      }
    }

    // ===== Render: curve editor =====
    const CURVE_H_CSS = 200;
    function renderCurve(cssW){
      const dpr = resizeCanvasToCss(curve, cssW, CURVE_H_CSS);
      const ctx = curve.getContext('2d');
      const w = curve.width, h = curve.height;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,w,h);

      const M = getMargins(dpr);
      const gx = M.l, gy = M.t, gw = w - M.l - M.r, gh = h - M.t - M.b;

      ctx.fillStyle = '#0b0b0b'; ctx.fillRect(0,0,w,h);
      ctx.fillStyle = '#111'; ctx.fillRect(gx, gy, gw, gh);

      // ã‚°ãƒªãƒƒãƒ‰
      ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
      for (let i=0;i<=10;i++){
        const xx = gx + Math.round((i/10)* (gw-1)) + 0.5;
        const yy = gy + Math.round((i/10)* (gh-1)) + 0.5;
        ctx.beginPath(); ctx.moveTo(xx, gy); ctx.lineTo(xx, gy+gh); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(gx, yy); ctx.lineTo(gx+gw, yy); ctx.stroke();
      }
      // ä¸­å¤®ç·š 0.5
      ctx.strokeStyle = '#333';
      const cxLine = gx + Math.round(0.5*(gw-1)) + 0.5;
      ctx.beginPath(); ctx.moveTo(cxLine, gy); ctx.lineTo(cxLine, gy+gh); ctx.stroke();

      // è»¸ãƒ©ãƒ™ãƒ«
      ctx.fillStyle = '#aaa'; ctx.font = Math.floor(12*dpr)+'px ui-sans-serif,system-ui,-apple-system'; ctx.textAlign='center'; ctx.textBaseline='top';
      for (let i=0;i<=10;i+=2){
        const xx = gx + Math.round((i/10)*(gw-1));
        ctx.fillText((i/10).toFixed(1), xx, gy+gh+Math.floor(6*dpr));
      }
      ctx.save();
      ctx.translate(Math.floor(18*dpr), gy+gh/2);
      ctx.rotate(-Math.PI/2);
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('è‰²æ¸©åº¦ (0..1)', 0, 0);
      ctx.restore();

            // æ›²ç·šã‚µãƒ³ãƒ—ãƒ«ç·šï¼ˆå¸¸ã«ç¾åœ¨ã®å†ç”Ÿãƒ˜ãƒƒãƒ‰ä½ç½®ã®è‰²æ¸©åº¦ã‚«ãƒ¼ãƒ–ã‚’è¡¨ç¤ºï¼‰
      ctx.save();
      ctx.beginPath();
      ctx.rect(gx, gy, gw, gh);
      ctx.clip();
      ctx.lineWidth = Math.max(1, Math.floor(2*dpr));
      ctx.strokeStyle = '#6ee7b7';
      
      let first = true;
      for (let i=0;i<gw;i++){
        const xNorm = i/(gw-1);
        // æ–°ã—ã„æ™‚é–“è£œå®Œé–¢æ•°ã‚’ä½¿ç”¨
        const y = getCurrentCurveValue(xNorm);
        const px = gx + i + 0.5;
        const py = gy + (1 - y)*(gh-1) + 0.5;
        if(first){ ctx.beginPath(); ctx.moveTo(px, py); first=false; }
        else { ctx.lineTo(px, py); }
      }
      ctx.stroke();
      ctx.restore();

      // åˆ¶å¾¡ç‚¹ï¼ˆå·¦åŠåˆ†ï¼‰ã¨ãƒŸãƒ©ãƒ¼ç‚¹ï¼ˆå³åŠåˆ†ï¼‰
      // æ›²ç·šã¨åŒã˜è¨ˆç®—æ–¹æ³•ã§åˆ¶å¾¡ç‚¹ã®ä½ç½®ã‚’è¡¨ç¤º
      const currentPoints = getCurrentPlaybackPoints();
      
      for (const p of currentPoints){
        // åˆ¶å¾¡ç‚¹ã®xåº§æ¨™ã§ã®æ›²ç·šã®å€¤ã‚’è¨ˆç®—ï¼ˆæ›²ç·šã¨åŒã˜è¨ˆç®—æ–¹æ³•ï¼‰
        const curveY = getCurrentCurveValue(p.x);
        
        const xL = gx + Math.round(p.x*(gw-1)) + 0.5;
        const yM = gy + Math.round((1 - curveY)*(gh-1)) + 0.5;
        // å·¦ï¼ˆç·¨é›†å¯èƒ½ï¼‰
        ctx.fillStyle = '#e5fff5';
        ctx.strokeStyle = '#1f8a5a';
        ctx.lineWidth = Math.max(1, Math.floor(2*dpr));
        ctx.beginPath(); ctx.arc(xL, yM, Math.max(3, Math.floor(5*dpr)), 0, Math.PI*2); ctx.fill(); ctx.stroke();
        // å³ï¼ˆãƒŸãƒ©ãƒ¼è¡¨ç¤ºï¼‰
        const xR = gx + Math.round((1 - p.x)*(gw-1)) + 0.5;
        ctx.strokeStyle = '#63b3a7';
        ctx.fillStyle = 'rgba(229,255,245,0.25)';
        ctx.beginPath(); ctx.arc(xR, yM, Math.max(3, Math.floor(5*dpr)), 0, Math.PI*2); ctx.fill(); ctx.stroke();
      }

      ctx.strokeStyle = '#2a2a2a'; ctx.lineWidth = Math.max(1, Math.floor(1*dpr));
      ctx.strokeRect(gx, gy, gw, gh);

      curve._layout = { dpr, gx, gy, gw, gh };
    }

    // ===== Render: timeline =====
    function renderTimeline(cssW){
      const dpr = resizeCanvasToCss(timeline, cssW, 64);
      const ctx = timeline.getContext('2d');
      const w = timeline.width, h = timeline.height;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,w,h);

      const M = getMargins(dpr);
      const gx = M.l, gy = Math.floor(10*dpr), gw = w - M.l - M.r, gh = h - gy - Math.floor(10*dpr);

      ctx.fillStyle = '#0b0b0b'; ctx.fillRect(0,0,w,h);
      ctx.fillStyle = '#111'; ctx.fillRect(gx, gy, gw, gh);

      // ã‚»ã‚³ãƒ³ãƒ‰ç›®ç››
      const secStep = Math.max(0.1, Math.pow(10, Math.floor(Math.log10(duration)) - 1));
      ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
      for (let t=0; t<=duration+1e-6; t+=secStep){
        const tn = t/duration; const x = gx + Math.round(tn*(gw-1)) + 0.5;
        ctx.beginPath(); ctx.moveTo(x, gy); ctx.lineTo(x, gy+gh); ctx.stroke();
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ˜ãƒƒãƒ‰
      const tn = clamp(time/duration, 0, 1); const xPH = gx + Math.round(tn*(gw-1)) + 0.5;
      ctx.strokeStyle = '#e6e6e6'; ctx.lineWidth = Math.max(1, Math.floor(2*dpr));
      ctx.beginPath(); ctx.moveTo(xPH, gy-4); ctx.lineTo(xPH, gy+gh+4); ctx.stroke();

      // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆãƒ€ã‚¤ãƒ¤ï¼‰
      sortKeyframes();
      for (let i=0;i<keyframes.length;i++){
        const kf = keyframes[i];
        const x = gx + Math.round((kf.t/duration)*(gw-1)) + 0.5;
        const r = Math.max(4, Math.floor(6*dpr));
        ctx.save();
        ctx.translate(x, gy + gh/2);
        ctx.rotate(Math.PI/4);
        ctx.fillStyle = (i===selectedKF)?'#8ff0c6':'#cfe9de';
        ctx.strokeStyle = (i===selectedKF)?'#1f8a5a':'#4a7a6e';
        ctx.lineWidth = Math.max(1, Math.floor(2*dpr));
        ctx.beginPath();
        ctx.rect(-r, -r, 2*r, 2*r);
        ctx.fill(); ctx.stroke();
        ctx.restore();
      }
      
      // é¸æŠã•ã‚Œã¦ã„ãªã„å ´åˆã®è¡¨ç¤º
      if (selectedKF === -1) {
        ctx.fillStyle = '#666';
        ctx.font = Math.floor(10*dpr)+'px ui-sans-serif,system-ui,-apple-system';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ æœªé¸æŠ', gx + gw/2, gy + gh + 4);
      }

      // ãƒ©ãƒ™ãƒ«
      ctx.fillStyle = '#aaa'; ctx.font = Math.floor(12*dpr)+'px ui-sans-serif,system-ui,-apple-system';
      ctx.textAlign='left'; ctx.textBaseline='top';
      ctx.fillText(`duration ${duration.toFixed(2)}s  / time ${time.toFixed(2)}s`, gx, 2);

      timeline._layout = { dpr, gx, gy, gw, gh };
    }

    function render(){
      const cssW = getCssWidth();
      renderBar(cssW);
      renderAxis(cssW);
      renderLamp(cssW);
      renderLampAxis(cssW);
      renderCurve(cssW);
      renderTimeline(cssW);
    }

    // ===== Audio: flash.wav trigger on threshold =====
    let audioCtx = null;
    let flashBuffer = null;
    let audioLoaded = false;
    let htmlAudio = null; // fallback element
    let audioInitialized = false;
    // Hum (buzz) nodes
    let humGain = null;
    let humOsc1 = null;
    let humOsc2 = null;
    let humLfo = null;
    let humLfoGain = null;
    let isHumRunning = false;
    const HUM_BASE_GAIN = 0.025; // æœ€å¤§æ™‚ã®åŸºæº–ã‚²ã‚¤ãƒ³
    let humAvgEma = 0.0;         // è‰²æ¸©åº¦ã®æŒ‡æ•°ç§»å‹•å¹³å‡
    const HUM_EMA_ALPHA = 0.2;   // å¿œç­”ä¿‚æ•°ï¼ˆ0..1ï¼‰
    async function ensureAudio(){
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') await audioCtx.resume();
        if (!audioLoaded){
          const isFile = location.protocol === 'file:';
          if (!isFile){
            try {
              const res = await fetch('flash.wav');
              if (!res.ok) throw new Error('fetch failed');
              const arr = await res.arrayBuffer();
              flashBuffer = await audioCtx.decodeAudioData(arr);
              audioLoaded = true;
            } catch {}
          }
          if (!audioLoaded){
            // Fallback: HTMLAudioElement
            if (!htmlAudio){
              htmlAudio = new Audio('flash.wav');
              htmlAudio.preload = 'auto';
            }
          }
        }
      } catch {}
    }
    function playFlash(){
      // pick a wider random range and random start offset
      const rate = 0.9 + Math.random()*0.20; // 0.85x..1.15x
      const offset = Math.random() * 0.02;    // up to 20ms offset
      // Prefer WebAudio if buffer available
      if (audioCtx && flashBuffer){
        const src = audioCtx.createBufferSource();
        src.buffer = flashBuffer;
        // use both detune (cents) and playbackRate for broader device support
        if (typeof src.detune === 'object' || typeof src.detune === 'number'){
          try { src.detune.value = (Math.random()*200 - 100); } catch {}
        }
        try { src.playbackRate.value = rate; } catch {}
        src.connect(audioCtx.destination);
        try { src.start(0, offset); } catch {}
        return;
      }
      // Fallback: HTMLAudioElement (clone to allow overlap)
      if (htmlAudio){
        try {
          const a = htmlAudio.cloneNode(true);
          // ensure pitch follows playbackRate on all browsers
          try { a.preservesPitch = false; } catch {}
          try { a.mozPreservesPitch = false; } catch {}
          try { a.webkitPreservesPitch = false; } catch {}
          a.playbackRate = rate;
          // apply small start offset when possible
          try { a.currentTime = offset; } catch {}
          a.play().catch(()=>{});
        } catch {}
      }
    }
    let wasAboveFlash = false;
    function computeMaxCurveValue(){
      let maxY = 0;
      const S = 32;
      for (let i=0;i<S;i++){
        const x = i/(S-1);
        const y = getCurrentCurveValue(x);
        if (y > maxY) maxY = y;
      }
      return maxY;
    }
    function computeAvgCurveValue(){
      let sumY = 0;
      const S = 32;
      for (let i=0;i<S;i++){
        const x = i/(S-1);
        sumY += getCurrentCurveValue(x);
      }
      return sumY / S;
    }
    function updateHumDynamics(){
      if (!audioCtx || !humGain) return;
      const avg = computeAvgCurveValue();
      humAvgEma = HUM_EMA_ALPHA * avg + (1 - HUM_EMA_ALPHA) * humAvgEma;
      const target = Math.max(0, Math.min(1, 1 - humAvgEma)) * HUM_BASE_GAIN;
      try { humGain.gain.setTargetAtTime(target, audioCtx.currentTime, 0.05); } catch {}
    }
    async function checkFlash(){
      const maxY = computeMaxCurveValue();
      const above = maxY > 0.7;
      if (!wasAboveFlash && above){
        await ensureAudio();
        playFlash();
      }
      wasAboveFlash = above;
    }

    // Continuous hum while playing
    async function startHum(){
      await ensureAudio();
      if (!audioCtx) return;
      if (isHumRunning) return;
      humGain = audioCtx.createGain();
      humGain.gain.value = HUM_BASE_GAIN; // åˆæœŸå€¤
      humGain.connect(audioCtx.destination);
      // base hum: 100 Hz sine + 200 Hz sine (subtle)
      humOsc1 = audioCtx.createOscillator();
      humOsc1.type = 'sine';
      humOsc1.frequency.value = 100;
      humOsc1.connect(humGain);
      humOsc2 = audioCtx.createOscillator();
      humOsc2.type = 'sine';
      humOsc2.frequency.value = 200;
      humOsc2.connect(humGain);
      try { humOsc1.start(); } catch {}
      try { humOsc2.start(); } catch {}
      isHumRunning = true;
    }
    function stopHum(){
      if (!audioCtx) return;
      if (!isHumRunning) return;
      // fade out
      try {
        const now = audioCtx.currentTime;
        humGain.gain.setTargetAtTime(0.0, now, 0.15);
      } catch {}
      const toStop = [humOsc1, humOsc2];
      setTimeout(()=>{
        for (const n of toStop){ try { n && n.stop(); } catch {} }
        humOsc1 = humOsc2 = null;
        if (humGain){ try { humGain.disconnect(); } catch {} humGain = null; }
        if (humLfoGain){ try { humLfoGain.disconnect(); } catch {} humLfoGain = null; }
        isHumRunning = false;
      }, 400);
    }

    // Initialize audio on first user gesture to satisfy autoplay policies
    function initAudioOnGesture(){
      if (audioInitialized) return;
      audioInitialized = true;
      ensureAudio();
    }
    window.addEventListener('pointerdown', initAudioOnGesture, { once: true });
    window.addEventListener('keydown', (e)=>{ if (e.code === 'Space' || e.key === 'Enter') initAudioOnGesture(); }, { once: true });

    // ===== Time controls =====
    function syncTimeUI(){
      time = clamp(time, 0, duration);
      timeVal.textContent = `${time.toFixed(2)}s`;
      // å†ç”Ÿãƒ˜ãƒƒãƒ‰ãŒç§»å‹•ã—ãŸæ™‚ã«ç·¨é›†ç”¨ã®åˆ¶å¾¡ç‚¹ã‚‚åŒæœŸ
      syncEditorPointsToCurrentTime();
      renderLamp(getCssWidth());
      renderTimeline(getCssWidth());
      checkFlash();
      updateHumDynamics();
    }
    durationInput.addEventListener('change', ()=>{
      duration = Math.max(0.1, Number(durationInput.value));
      // ç¯„å›²å¤–ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã¯å†…å´ã«ã‚¯ãƒ©ãƒ³ãƒ—
      for (const kf of keyframes){ kf.t = clamp(kf.t, 0, duration); }
      sortKeyframes();
      if (time > duration) time = duration;
      syncTimeUI();
    });
    loopChk.addEventListener('change', ()=>{ loopPlay = !!loopChk.checked; });

    // Play/Pause
    function tick(ts){
      if (!playing){ lastTS = ts; return; }
      const dt = (ts - lastTS) / 1000; lastTS = ts;
      time += dt;
      if (time > duration){
        if (loopPlay){ 
          time = time % duration; 
        } else { 
          time = duration; 
          setPlaying(false); 
        }
      }
      syncTimeUI();
      // å†ç”Ÿä¸­ã¯è‰²æ¸©åº¦ã‚«ãƒ¼ãƒ–ã‚‚ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°
      renderCurve(getCssWidth());
      requestAnimationFrame(tick);
    }
    function setPlaying(v){
      playing = v; playBtn.textContent = v ? 'â¸ åœæ­¢' : 'â–¶ å†ç”Ÿ';
      if (v) {
        // å†ç”Ÿé–‹å§‹æ™‚ã«ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®é¸æŠã‚’è§£é™¤
        selectedKF = -1;
        // æœ€å¾Œã®çŠ¶æ…‹ã§å†ç”Ÿé–‹å§‹ã™ã‚‹å ´åˆã¯æœ€åˆã«æˆ»ã‚‹
        if (time >= duration) {
          time = 0;
        }
        // ensure audio and start hum while playing
        startHum();
        requestAnimationFrame((ts)=>{ lastTS = ts; requestAnimationFrame(tick); });
      } else {
        // stop hum when paused
        stopHum();
      }
    }
    playBtn.addEventListener('click', ()=> setPlaying(!playing));
    window.addEventListener('keydown', (e)=>{
      if (e.code === 'Space') {
        e.preventDefault();
        setPlaying(!playing);
      } else if (e.code === 'ArrowLeft') {
        e.preventDefault();
        const step = e.shiftKey ? 0.1 : 0.01;
        time = clamp(time - step, 0, duration);
        syncTimeUI();
        // ç·¨é›†ç”¨ã®åˆ¶å¾¡ç‚¹ã‚’ç¾åœ¨ã®æ™‚é–“ä½ç½®ã«åŒæœŸ
        syncEditorPointsToCurrentTime();
        renderCurve(getCssWidth());
      } else if (e.code === 'ArrowRight') {
        e.preventDefault();
        const step = e.shiftKey ? 0.1 : 0.01;
        time = clamp(time + step, 0, duration);
        syncTimeUI();
        // ç·¨é›†ç”¨ã®åˆ¶å¾¡ç‚¹ã‚’ç¾åœ¨ã®æ™‚é–“ä½ç½®ã«åŒæœŸ
        syncEditorPointsToCurrentTime();
        renderCurve(getCssWidth());
      }
    });

    // ===== Timeline interactions =====
    let dragKF = null; // { idx, startX, moved, origT }
    let dragPlayhead = null; // { startX, moved, isDragging }
    function tToX(t){ const L=timeline._layout; const {gx,gw}=L; return gx + Math.round((t/duration)*(gw-1)) + 0.5; }
    function xToT(xCSS){ const L=timeline._layout; const {dpr,gx,gw}=L; const xd=xCSS*dpr; const tn=clamp((xd-gx)/(gw-1),0,1); return tn*duration; }

    function hitTestKF(xCSS, yCSS){ return -1; }

    // å†ç”Ÿãƒ˜ãƒƒãƒ‰ã®ãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
    function hitTestPlayhead(xCSS, yCSS){
      const L = timeline._layout; if(!L) return false; const {dpr, gy, gh} = L;
      const cx = xCSS * dpr, cy = yCSS * dpr;
      const playheadX = tToX(time);
      const dx = playheadX - cx, dy = (gy + gh/2) - cy;
      const d2 = dx*dx + dy*dy;
      return d2 < Math.pow(15*dpr,2); // å†ç”Ÿãƒ˜ãƒƒãƒ‰ã®ãƒ’ãƒƒãƒˆç¯„å›²
    }

    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
    function handleGlobalPointerMove(e) {
      if (dragPlayhead && dragPlayhead.isDragging) {
        const rect = timeline.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã®ç¯„å›²å†…ã‹ãƒã‚§ãƒƒã‚¯
        if (x >= 0 && x <= rect.width && y >= 0 && y <= rect.height) {
          const t = xToT(x);
          time = clamp(t, 0, duration);
          // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã‚‚ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ›´æ–°
          syncTimeUI();
          // ç·¨é›†ç”¨ã®åˆ¶å¾¡ç‚¹ã‚’ç¾åœ¨ã®æ™‚é–“ä½ç½®ã«åŒæœŸ
          syncEditorPointsToCurrentTime();
          renderCurve(getCssWidth());
        } else {
          // ç¯„å›²å¤–ã§ã‚‚é©åˆ‡ã«æ™‚é–“ã‚’æ›´æ–°ï¼ˆå¢ƒç•Œå€¤ã«ã‚¯ãƒ©ãƒ³ãƒ—ï¼‰
          let t;
          if (x < 0) {
            t = 0; // å·¦ç«¯
          } else if (x > rect.width) {
            t = duration; // å³ç«¯
          } else {
            t = xToT(x);
          }
          time = clamp(t, 0, duration);
          // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã‚‚ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ›´æ–°
          syncTimeUI();
          // ç·¨é›†ç”¨ã®åˆ¶å¾¡ç‚¹ã‚’ç¾åœ¨ã®æ™‚é–“ä½ç½®ã«åŒæœŸ
          syncEditorPointsToCurrentTime();
          renderCurve(getCssWidth());
        }
      }
    }

    function handleGlobalPointerUp(e) {
      if (dragPlayhead && dragPlayhead.isDragging) {
        dragPlayhead.isDragging = false;
        dragPlayhead = null;
        timeline.style.cursor = 'crosshair';
        renderTimeline(getCssWidth());
        
        // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’è§£é™¤
        try {
          timeline.releasePointerCapture(e.pointerId);
        } catch (err) {
          // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚­ãƒ£ãƒ—ãƒãƒ£ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
        document.removeEventListener('pointermove', handleGlobalPointerMove);
        document.removeEventListener('pointerup', handleGlobalPointerUp);
      }
    }

    timeline.addEventListener('pointerdown', (e)=>{
      const rect = timeline.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const idx = hitTestKF(x, y);
      
      if (hitTestPlayhead(x, y)) {
        // å†ç”Ÿãƒ˜ãƒƒãƒ‰ã‚’ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
        dragPlayhead = { startX: x, moved: false, isDragging: true };
        timeline.style.cursor = 'grabbing';
        // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’è¨­å®š
        timeline.setPointerCapture(e.pointerId);
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);
      } else {
        // ç©ºæ‰€ã‚¯ãƒªãƒƒã‚¯ã§å†ç”Ÿãƒ˜ãƒƒãƒ‰ã‚’ç§»å‹•ã—ã€ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
        const t = xToT(x);
        time = t;
        syncTimeUI();
        // ç·¨é›†ç”¨ã®åˆ¶å¾¡ç‚¹ã‚’ç¾åœ¨ã®æ™‚é–“ä½ç½®ã«åŒæœŸ
        syncEditorPointsToCurrentTime();
        renderCurve(getCssWidth());
        
        // ç©ºæ‰€ã‚¯ãƒªãƒƒã‚¯ã§ã‚‚å†ç”Ÿãƒ˜ãƒƒãƒ‰ãƒ‰ãƒ©ãƒƒã‚°ã‚’é–‹å§‹
        dragPlayhead = { startX: x, moved: false, isDragging: true };
        timeline.style.cursor = 'grabbing';
        // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’è¨­å®š
        timeline.setPointerCapture(e.pointerId);
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
        document.addEventListener('pointermove', handleGlobalPointerMove);
        document.addEventListener('pointerup', handleGlobalPointerUp);
      }
    });
    
    timeline.addEventListener('pointermove', (e)=>{
      if (!timeline._layout) return;
      const rect = timeline.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      
      // ã‚«ãƒ¼ã‚½ãƒ«ã‚¹ã‚¿ã‚¤ãƒ«ã®æ›´æ–°ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ä¸­ã§ãªã„å ´åˆã®ã¿ï¼‰
      if (!dragPlayhead || !dragPlayhead.isDragging) {
        if (hitTestKF(x,y) >= 0) {
          timeline.style.cursor = 'grab';
        } else if (hitTestPlayhead(x, y)) {
          timeline.style.cursor = 'grab';
        } else {
          timeline.style.cursor = 'crosshair';
        }
      }
      
      // ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç†ã¯ç„¡åŠ¹åŒ–
      
      // å†ç”Ÿãƒ˜ãƒƒãƒ‰ã®ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç†ï¼ˆã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³å†…ã§ã®ã¿ï¼‰
      if (dragPlayhead && dragPlayhead.isDragging) {
        dragPlayhead.moved = dragPlayhead.moved || (Math.abs(x - dragPlayhead.startX) > 2);
        const t = xToT(x);
        time = clamp(t, 0, duration);
        // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã‚‚ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ›´æ–°
        syncTimeUI();
        // ç·¨é›†ç”¨ã®åˆ¶å¾¡ç‚¹ã‚’ç¾åœ¨ã®æ™‚é–“ä½ç½®ã«åŒæœŸ
        syncEditorPointsToCurrentTime();
        renderCurve(getCssWidth());
      }
    });
    
    timeline.addEventListener('pointerup', (e)=>{});

    // Buttons for KF
    

    // ===== Curve editor interactions =====
    let drag = null; // { id, startX, startY, moved }

    function hitTestPoint(xCSS, yCSS){
      const L = curve._layout; if(!L) return null;
      const { dpr, gx, gy, gw, gh } = L;
      const r = Math.max(6, Math.floor(9*dpr));
      const cx = xCSS * dpr, cy = yCSS * dpr;
      let found = null, best = 1e9;
      for (const p of points){
        const leftX  = gx + Math.round(p.x*(gw-1)) + 0.5;
        const rightX = gx + Math.round((1 - p.x)*(gw-1)) + 0.5;
        const curveY = getCurrentCurveValue(p.x);
        const yM    = gy + Math.round((1 - curveY)*(gh-1)) + 0.5;
        let dx = leftX - cx, dy = yM - cy; let d2 = dx*dx + dy*dy;
        if (d2 < r*r && d2 < best){ best = d2; found = { id: p.id }; }
        dx = rightX - cx; dy = yM - cy; d2 = dx*dx + dy*dy;
        if (d2 < r*r && d2 < best){ best = d2; found = { id: p.id }; }
      }
      return found;
    }

    function cssToNorm(xCSS, yCSS){
      const L = curve._layout; if(!L) return {x:0,y:0};
      const { dpr, gx, gy, gw, gh } = L;
      const xd = xCSS * dpr, yd = yCSS * dpr;
      const x = clamp((xd - gx) / (gw - 1), 0, 1);
      const y = clamp(1 - (yd - gy) / (gh - 1), 0, 1);
      return {x, y};
    }

    curve.addEventListener('pointerdown', (e)=>{
      curve.setPointerCapture(e.pointerId);
      const rect = curve.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      const target = hitTestPoint(x, y);
      if (target){
        drag = { id: target.id, startX: x, startY: y, moved: false };
        curve.style.cursor = 'grabbing';
  } else {
        // ç©ºæ‰€ã‚¯ãƒªãƒƒã‚¯: ç‚¹ã‚’å³æ™‚ä½œæˆã—ã€ãƒ‰ãƒ©ãƒƒã‚°å¯¾è±¡ã«ã™ã‚‹
        const {x: xn, y: yn} = cssToNorm(x, y);
        const s = xn <= 0.5 ? xn : 1 - xn;
        const newPoint = { id: nextPointId++, x: clamp(s, 0, 0.5), y: yn };
        points.push(newPoint);
        sortPoints(points);
        updateSelectedKFPointsFromEditor();
        drag = { id: newPoint.id, startX: x, startY: y, moved: false };
        curve.style.cursor = 'grabbing';
        render();
      }
    });

    curve.addEventListener('pointermove', (e)=>{
      const rect = curve.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;

      if (!drag){
        curve.style.cursor = hitTestPoint(x, y) ? 'grab' : 'crosshair';
        return;
      }

      const moved = drag.moved || (Math.hypot(x - drag.startX, y - drag.startY) > 3);
      drag.moved = moved;

      if (drag.id){
        const p = points.find(pp=>pp.id===drag.id);
        if (p){
          const {x: xn, y: yn} = cssToNorm(x, y);
          const s = xn <= 0.5 ? xn : 1 - xn; // å·¦åŠåˆ†ã¸æŠ˜ã‚Šè¿”ã—
          const newX = clamp(s, 0, 0.5);
          const newY = yn;
          if (newX !== p.x || newY !== p.y){
            p.x = newX;
            p.y = newY;
            sortPoints(points);
            updateSelectedKFPointsFromEditor();
            render();
          }
        }
      }
    });

    curve.addEventListener('pointerup', (e)=>{
      const rect = curve.getBoundingClientRect();
      const x = e.clientX - rect.left; const y = e.clientY - rect.top;
      if (!drag){ return; }

      // pointerdownã§å¿…è¦ã«å¿œã˜ã¦ä½œæˆæ¸ˆã¿ã®ãŸã‚ã€ã“ã“ã§ã¯è¿½åŠ ãƒ»å‰Šé™¤ã®ã„ãšã‚Œã‚‚è¡Œã‚ãªã„
       drag = null; curve.style.cursor = 'crosshair';
    });

    
    // ===== Preset & IO helpers =====
    function makePoints(y0, y1, y2, y3){
      // Consistent IDs so interpolation is stable across KFs
      return [
        { id: 101, x: 0.02, y: y0 },
        { id: 102, x: 0.12, y: y1 },
        { id: 103, x: 0.25, y: y2 },
        { id: 104, x: 0.50, y: y3 },
      ];
    }
    function shapeOff(){ return makePoints(0.0, 0.0, 0.0, 0.0); }
    function shapeEndsGlow(s){ // s: 0..1 strength
      const e = Math.min(1, Math.max(0, s));
      // ends high, center low
      return makePoints(0.55*e, 0.35*e + 0.05, 0.15*e + 0.03, 0.06*e + 0.02);
    }
    function shapeFlash(){ return makePoints(0.95, 0.95, 0.92, 0.88); }
    function shapeRamp(a){ // a: 0..1 progress toward white
      const k = Math.min(1, Math.max(0, a));
      // gently lift whole tube; keep ends slightly ahead of center
      return makePoints(0.8 + 0.2*k, 0.65 + 0.35*k, 0.5 + 0.5*k, 0.38 + 0.62*k);
    }
    function shapeWhite(){ return makePoints(1.0, 1.0, 1.0, 1.0); }

    function setKeyframesFromSpec(spec, setDuration){
      if (setDuration) {
        duration = setDuration;
        durationInput.value = String(setDuration.toFixed(2));
      }
      keyframes = [];
      nextKFId = 1;
      for (const {t, pts} of spec){
        const P = deepCopyPoints(pts);
        keyframes.push({ id: nextKFId++, t, points: P, lut: makeLUT(P) });
      }
      sortKeyframes();
      selectedKF = 0;
      // Sync editor "points" to selected
      points = deepCopyPoints(keyframes[0].points);
      nextPointId = points.reduce((m,p)=>Math.max(m,p.id),0) + 1;
      time = 0;
      syncTimeUI();
      render();
    }

    function presetThreeTriesThenStable(){
      const D = duration; // use current duration
      
      // æœ€åˆã®æºœã‚ã‚’å¤§ããå–ã‚Šã€æ®‹ã‚Šã‚’1.0~2.0ç§’ã«åœ§ç¸®
      const rampStart = Math.max(1.0, D - 2.0); // æ®‹ã‚Š2ç§’ä»¥å†…ã§é–‹å§‹
      const rampDuration = Math.min(2.0, D - rampStart); // å®Ÿéš›ã®åœ§ç¸®æ™‚é–“
      
      // æ™‚é–“é…åˆ†ã‚’èª¿æ•´
      const spec = [
        { t: 0.00, pts: shapeOff() },

        // Attempt 1 (åœ§ç¸®æ™‚é–“å†…) - é‹­ã„ç‚¹æ»…
        { t: rampStart + rampDuration * 0.1, pts: shapeEndsGlow(0.8) },
        { t: rampStart + rampDuration * 0.12, pts: shapeFlash() },
        { t: rampStart + rampDuration * 0.14, pts: shapeOff() },

        // Attempt 2 (åœ§ç¸®æ™‚é–“å†…) - é‹­ã„ç‚¹æ»…
        { t: rampStart + rampDuration * 0.35, pts: shapeEndsGlow(0.9) },
        { t: rampStart + rampDuration * 0.37, pts: shapeFlash() },
        { t: rampStart + rampDuration * 0.39, pts: shapeOff() },

        // Attempt 3 (åœ§ç¸®æ™‚é–“å†…) - é‹­ã„ç‚¹æ»…
        { t: rampStart + rampDuration * 0.6, pts: shapeEndsGlow(1.0) },
        { t: rampStart + rampDuration * 0.62, pts: shapeFlash() },
        { t: rampStart + rampDuration * 0.64, pts: shapeEndsGlow(1.0) },

        // ä¸¡ç«¯ãŒç™½ãå…‰ã‚Šã€ãã®å¾Œå…¨ä½“ãŒãƒ‘ãƒƒã¨ç™½ããªã‚‹
        { t: rampStart + rampDuration * 0.8, pts: shapeEndsGlow(1.0) }, // ä¸¡ç«¯ãŒç™½ãå…‰ã‚‹
        { t: rampStart + rampDuration * 0.85, pts: shapeEndsGlow(1.0) }, // å°‘ã—æºœã‚
        { t: rampStart + rampDuration * 0.9, pts: shapeWhite() }, // å…¨ä½“ãŒãƒ‘ãƒƒã¨ç™½ããªã‚‹
        { t: D, pts: shapeWhite() }, // æœ€çµ‚çŠ¶æ…‹
      ];
      setKeyframesFromSpec(spec);
    }

    function resetKeyframes(){
      initDefaultKeyframes();
      // Reset edit points to the first KF
      points = deepCopyPoints(keyframes[0].points);
      nextPointId = points.reduce((m,p)=>Math.max(m,p.id),0) + 1;
      time = 0;
      syncTimeUI();
      render();
    }

    function exportJSON(){
      const payload = {
        version: 1,
        duration,
        keyframes: keyframes.map(k => ({ t: k.t, points: k.points })),
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], {type: "application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "fluorescent_timeline.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    }

    // ===== å†…éƒ¨JSONç”Ÿæˆå™¨ =====
    function mulberry32(seed){
      let t = seed >>> 0;
      return function(){
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }
    function clamp01(v){ return Math.max(0, Math.min(1, v)); }
    
    // ã‚¬ã‚¦ã‚¹åˆ†å¸ƒï¼ˆæ­£è¦åˆ†å¸ƒï¼‰ã®ä¹±æ•°ç”Ÿæˆï¼ˆBox-Mullerå¤‰æ›ï¼‰
    function gaussianRandom(mean, stdDev, rndFunc){
      let u1, u2;
      do {
        u1 = rndFunc();
        u2 = rndFunc();
      } while (u1 === 0); // u1ãŒ0ã®å ´åˆã¯å†ç”Ÿæˆ
      
      // Box-Mullerå¤‰æ›
      const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
      return mean + z0 * stdDev;
    }
    
    // ã‚¬ã‚¦ã‚¹åˆ†å¸ƒã§ç¯„å›²åˆ¶é™ã•ã‚ŒãŸä¹±æ•°ç”Ÿæˆ
    function gaussianRange(mean, stdDev, min, max, rndFunc){
      let result;
      do {
        result = gaussianRandom(mean, stdDev, rndFunc);
      } while (result < min || result > max);
      return result;
    }
    function generateFluorescentTimeline({
      version = 1,
      duration = 2.0,
      controlPoints,
      seed = 42,
      params = {}
    }){
      const rnd = mulberry32(seed);
      const p = {
        baseGain: 0.85,
        spread: 0.20,
        gainPow: 1.25,
        midRange: [0.25, 0.65],
        peakRange: [0.95, 1.0],
        zeroRange: [0.00, 0.06],
        dtRangeMs: [50, 85],
        decayRate: 0.018,
        noise: 0.015,
        // startTime ã‚’ç›¸å¯¾ãƒ¬ãƒ³ã‚¸ã§ãƒ©ãƒ³ãƒ€ãƒ åŒ–ï¼ˆdurationã«æ¯”ä¾‹ï¼‰
        startTimeRangeRel: [0.45, 0.65], // ä¾‹: duration=2s â†’ 0.90sã€œ1.30sï¼ˆæœªä½¿ç”¨æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        // çµ¶å¯¾æ™‚é–“ã§ã®é–‹å§‹ãƒ¬ãƒ³ã‚¸ï¼ˆå„ªå…ˆï¼‰
        startTimeAbsRange: [0.96, 1.06], // 1ãƒ‘ãƒ«ã‚¹ç›®ã¯1.0ç§’ä»˜è¿‘ã‹ã‚‰
        // è¿½åŠ ã®å…¨ä½“ãƒ©ãƒ³ãƒ€ãƒ æ€§
        globalJitterMs: 10,      // å„ã‚¤ãƒ™ãƒ³ãƒˆã®å¾®å°ã‚¸ãƒƒã‚¿
        // å…¨ä½“æ§‹æˆã®ãƒ©ãƒ³ãƒ€ãƒ æ€§
        // 1ãƒ‘ãƒ«ã‚¹ç›®ã¾ã§ã®æ™‚é–“ã‚’ãƒ©ãƒ³ãƒ€ãƒ åŒ–
        firstPulseDelayRange: [0.85, 1.15], // 1ãƒ‘ãƒ«ã‚¹ç›®é–‹å§‹æ™‚åˆ»ã®ç¯„å›²
        // å®‰å®šã¾ã§ã®æ™‚é–“ã‚’ãƒ©ãƒ³ãƒ€ãƒ åŒ–
        settleTimeRangeRel: [0.15, 0.35], // durationã«å¯¾ã™ã‚‹æ¯”ç‡
        // å®‰å®šã¾ã§ã®ãƒ‘ãƒ«ã‚¹å›æ•°ã‚’ãƒ©ãƒ³ãƒ€ãƒ åŒ–
        pulseCountRange: [3, 8], // å®‰å®šã¾ã§ã®ãƒ‘ãƒ«ã‚¹æ•°
        // å®‰å®šå¾Œã®æ™‚é–“ã‚’ç¢ºä¿
        stableTimeAfterSettle: 0.5, // å®‰å®šå¾Œã®æ™‚é–“ï¼ˆç§’ï¼‰
        // ãƒ‘ãƒ«ã‚¹é–“éš”ã®ãƒ©ãƒ³ãƒ€ãƒ æ€§å¼·åŒ–ï¼ˆã‚¬ã‚¦ã‚¹åˆ†å¸ƒï¼‰
        pulseIntervalRange: [40, 120], // ãƒ‘ãƒ«ã‚¹é–“éš”ï¼ˆmsï¼‰
        pulseIntervalStdDev: 35,       // ãƒ‘ãƒ«ã‚¹é–“éš”ã®æ¨™æº–åå·®ï¼ˆmsï¼‰- åˆ†æ•£ã‚’å¤§ãã
        burstIntervalRange: [80, 180], // ãƒãƒ¼ã‚¹ãƒˆé–“éš”ï¼ˆmsï¼‰
        burstIntervalStdDev: 50,       // ãƒãƒ¼ã‚¹ãƒˆé–“éš”ã®æ¨™æº–åå·®ï¼ˆmsï¼‰- åˆ†æ•£ã‚’å¤§ãã
        // ãƒ‘ãƒ«ã‚¹å½¢çŠ¶ï¼ˆé‹­ã„ç«‹ã¡ä¸ŠãŒã‚Šâ†’çŸ­ã„ãƒ”ãƒ¼ã‚¯â†’å³æ¸›è¡°ï¼‰
        pulseRiseMsRange: [8, 12],   // ç«‹ã¡ä¸ŠãŒã‚Šï¼ˆãƒ©ãƒ³ãƒ€ãƒ æ€§æŠ‘åˆ¶ï¼‰
        pulseHoldMsRange: [2, 4],    // ã”ãçŸ­ã„ãƒ›ãƒ¼ãƒ«ãƒ‰ï¼ˆãƒ©ãƒ³ãƒ€ãƒ æ€§æŠ‘åˆ¶ï¼‰
        pulseFallMsRange: [35, 45],  // æ¸›è¡°ï¼ˆãƒ©ãƒ³ãƒ€ãƒ æ€§æŠ‘åˆ¶ï¼‰
        pulseInterGapMsRange: [24, 70], // ãƒ‘ãƒ«ã‚¹é–“ã‚®ãƒ£ãƒƒãƒ—
        pulsesPerBurstRange: [1, 3], // 1å¡Šã®ãƒ‘ãƒ«ã‚¹æ•°
        burstGapMsRange: [60, 140],  // æ¬¡ã®å¡Šã¾ã§
        settleBufferMs: 100,
        useSampleIdProfiles: true,
        // ãƒ¬ã‚¢é•·æºœã‚ï¼ˆæ¥µç¨€ã«é•·ã„å¾…æ©Ÿã‚’æŒ¿å…¥ï¼‰
        rareLongTameProb: 0.06,             // 6% ã§é•·æºœã‚ã‚’ç™ºç”Ÿ
        rareLongTameMsRange: [600, 1800]    // 0.6ã€œ1.8ç§’ã®è¿½åŠ å¾…æ©Ÿ
      };
      Object.assign(p, params);
      const gain = (x) => clamp01(p.baseGain + p.spread * Math.pow(1 - x, p.gainPow));
      const rBetween = (a,b)=> a + (b-a) * rnd();
      const ms = (m)=> m/1000;

      // idåˆ¥ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆfluorescent_timeline_sample.json ã‚’è§£æï¼‰
      // Peak @tâ‰ˆ1.085: 101:0.90, 102:0.95, 103:0.88, 104:0.82 â†’ maxã§æ­£è¦åŒ–
      const peakWeights = new Map([[101, 0.90/0.95],[102,1.0],[103,0.88/0.95],[104,0.82/0.95]]);
      // Mid @tâ‰ˆ1.03: 101:0.24, 102:0.36, 103:0.12, 104:0.05 â†’ maxã§æ­£è¦åŒ–
      const midWeights  = new Map([[101, 0.24/0.36],[102,1.0],[103,0.12/0.36],[104,0.05/0.36]]);
      // Near-zero @tâ‰ˆ1.402 ç­‰: 101:0.03, 102:0.06, 103:0.02, 104:0.01 â†’ maxã§æ­£è¦åŒ–
      const zeroWeights = new Map([[101, 0.03/0.06],[102,1.0],[103,0.02/0.06],[104,0.01/0.06]]);
      function idWeight(id, phase){
        if (!p.useSampleIdProfiles) return 1.0;
        if (phase === 'peak') return peakWeights.get(id) ?? 1.0;
        if (phase === 'mid')  return midWeights.get(id)  ?? 1.0;
        if (phase === 'zero') return zeroWeights.get(id) ?? 1.0;
        return 1.0;
      }

      // ã‚¨ãƒãƒ«ã‚®ãƒ¼ä¾å­˜ã®ç©ºé–“æˆå½¢: ä½ã‚¨ãƒãƒ«ã‚®ãƒ¼æ™‚ã¯ä¸­å¤®ã‚’æŠ‘ãˆã€ä¸¡ç«¯ã®ã¿èµ¤ãè¦‹ã›ã‚‹
      function energyShapeFactor(x /*0..0.5*/, baseAmp){
        if (baseAmp < 0.28){
          // x=0ï¼ˆç«¯ï¼‰â†’1ï¼ˆä¸­å¿ƒï¼‰ç›¸å½“ã§ä¸­å¿ƒå´ã‚’å¤§ããæ¸›è¡°
          const k = Math.min(1, Math.max(0, x / 0.5));
          return 1 - 0.75 * k; // ä¸­å¤®ã§æœ€å¤§-75%
        }
        return 1.0;
      }
      // é«˜ã‚¨ãƒãƒ«ã‚®ãƒ¼æ™‚ã®è‰²æ¸©åº¦ç¢ºä¿: å…¨ä½“ãŒå…‰ã‚‹å ´åˆã¯é»„ã€œç™½å¸¯ã«æŒã¡ä¸Šã’ã‚‹
      function liftHighTempFloor(y, baseAmp){
        if (baseAmp > 0.82) return Math.max(y, 0.62);
        if (baseAmp > 0.70) return Math.max(y, 0.50);
        return y;
      }

      const keyframesGen = [];
      keyframesGen.push({ t: 0.0, points: controlPoints.map(cp=>({ id: cp.id, y: 0.0 })) });
      // åˆå›æºœã‚ï¼ˆé–‹å§‹æ™‚åˆ»ï¼‰ã‚’ãƒ©ãƒ³ãƒ€ãƒ åŒ–ï¼šçµ¶å¯¾ãƒ¬ãƒ³ã‚¸ãŒã‚ã‚Œã°å„ªå…ˆ
      const hasAbs = Array.isArray(p.startTimeAbsRange) && p.startTimeAbsRange.length===2;
      const tStartCandidate = hasAbs ? rBetween(p.startTimeAbsRange[0], p.startTimeAbsRange[1])
                                     : duration * rBetween(p.startTimeRangeRel[0], p.startTimeRangeRel[1]);
      const tStart = clamp(tStartCandidate, 0.05, Math.max(0.2, duration - 0.2));
      
      // å…¨ä½“æ§‹æˆã®ãƒ©ãƒ³ãƒ€ãƒ åŒ–
      const firstPulseTime = rBetween(p.firstPulseDelayRange[0], p.firstPulseDelayRange[1]);
      const settleTime = duration * rBetween(p.settleTimeRangeRel[0], p.settleTimeRangeRel[1]);
      const targetPulseCount = Math.floor(rBetween(p.pulseCountRange[0], p.pulseCountRange[1] + 1));
      
      // å‹•çš„ã«durationã‚’è¨ˆç®—ï¼ˆãƒ‘ãƒ«ã‚¹ç”Ÿæˆæ™‚é–“ + å®‰å®šå¾Œ0.5ç§’ï¼‰
      let estimatedDuration = 0;
      
      let t = tStart;
      let cycle = 0;
      const settleBuffer = ms(p.settleBufferMs);
      const jitter = ()=> ms(rBetween(-p.globalJitterMs, p.globalJitterMs));
      const maybeRareLongTame = ()=> (rnd() < p.rareLongTameProb ? ms(rBetween(p.rareLongTameMsRange[0], p.rareLongTameMsRange[1])) : 0);

      // 1ãƒ‘ãƒ«ã‚¹ï¼ˆriseâ†’holdâ†’fallï¼‰ã®ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ç¾¤ã‚’è¿½åŠ 
      function addPulseAt(timeBase, baseAmp, cycleScale, isLast){
        // æœ€å¾Œã®ãƒ‘ãƒ«ã‚¹å°‚ç”¨ã®ä¸Šæ›¸ãè¨­å®šï¼ˆå­˜åœ¨ã™ã‚Œã°å„ªå…ˆï¼‰
        const riseRange = isLast && p.lastPulse && Array.isArray(p.lastPulse.pulseRiseMsRange) ? p.lastPulse.pulseRiseMsRange : p.pulseRiseMsRange;
        const holdRange = isLast && p.lastPulse && Array.isArray(p.lastPulse.pulseHoldMsRange) ? p.lastPulse.pulseHoldMsRange : p.pulseHoldMsRange;
        const fallRange = isLast && p.lastPulse && Array.isArray(p.lastPulse.pulseFallMsRange) ? p.lastPulse.pulseFallMsRange : p.pulseFallMsRange;
        const peakScale = isLast && p.lastPulse && typeof p.lastPulse.peakScale === 'number' ? p.lastPulse.peakScale : 1.0;
        const zeroClamp = isLast && p.lastPulse && typeof p.lastPulse.zeroClamp === 'number' ? p.lastPulse.zeroClamp : null;

        const rise = ms(rBetween(riseRange[0], riseRange[1]));
        const hold = ms(rBetween(holdRange[0], holdRange[1]));
        const fall = ms(rBetween(fallRange[0], fallRange[1]));
        const t0 = timeBase;
        const t1 = t0 + rise;            // ç«‹ã¡ä¸ŠãŒã‚Šçµ‚ç«¯ï¼ˆä¸­ã€œé«˜ã®é–“ï¼‰
        const t2 = t1 + hold;            // ãƒ”ãƒ¼ã‚¯ç¶­æŒï¼ˆçŸ­ã„ï¼‰
        const t3 = t2 + fall;            // è¿‘ã‚¼ãƒ­ã¸æ¸›è¡°ï¼ˆæœ€å¾Œã¯ã‚¹ã‚­ãƒƒãƒ—å¯èƒ½ï¼‰

        // ç«‹ã¡ä¸ŠãŒã‚Šé€”ä¸­ã®ä¸­é–“ç‚¹ï¼ˆãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«midï¼‰
        const yMid = clamp01(baseAmp * (0.35 + 0.25 * rnd()));
        const mkPoints = (amp, phase)=> controlPoints.map(cp=>{
          const wId = idWeight(cp.id, phase);
          const shaped = (amp * peakScale) * cycleScale * wId * gain(cp.x) * energyShapeFactor(cp.x, amp * peakScale);
          let y = clamp01(shaped + rBetween(-p.noise, p.noise));
          y = liftHighTempFloor(y, amp);
          return { id: cp.id, y };
        });
        // t1: ç«‹ã¡ä¸ŠãŒã‚Šçµ‚ç«¯ï¼ˆä¸­é–“å¼·åº¦ï¼‰
        keyframesGen.push({ t: t1, points: mkPoints(yMid, 'mid') });
        // t2: ãƒ”ãƒ¼ã‚¯
        // æœ€å¾Œã®ãƒ‘ãƒ«ã‚¹ã¯å…¨xã§1.0å›ºå®š
        if (isLast) {
          keyframesGen.push({ t: t2, points: controlPoints.map(cp=>({ id: cp.id, y: 1.0 })) });
        } else {
          keyframesGen.push({ t: t2, points: mkPoints(baseAmp, 'peak') });
        }
        // t3: è¿‘ã‚¼ãƒ­
        if (!isLast) {
          const yZeroBase = rBetween(p.zeroRange[0], p.zeroRange[1]);
          const zeroPts = controlPoints.map(cp=>{
            const zMul = idWeight(cp.id, 'zero');
            const shaped = yZeroBase * cycleScale * zMul * energyShapeFactor(cp.x, yZeroBase);
            let y = clamp01(shaped + rBetween(-p.noise*0.5, p.noise*0.5));
            if (zeroClamp != null) y = Math.min(y, zeroClamp);
            return { id: cp.id, y };
          });
          keyframesGen.push({ t: t3, points: zeroPts });
          return t3;
        } else {
          // æœ€å¾Œã®ãƒ‘ãƒ«ã‚¹ã¯æš—ãã—ãªã„: ä»¥é™ã®æœ€çµ‚çŠ¶æ…‹ã¯1.0ã¸çµ±ä¸€
          return t2;
        }
      }

      // 1ãƒ‘ãƒ«ã‚¹ç›®ã¾ã§å¾…æ©Ÿ
      if (t < firstPulseTime) {
        t = firstPulseTime + maybeRareLongTame();
      }

      // å®‰å®šã¾ã§ã®ãƒ‘ãƒ«ã‚¹ç”Ÿæˆï¼ˆå›æ•°åˆ¶å¾¡ï¼‰
      let pulseCount = 0;
      while (pulseCount < targetPulseCount && t + settleBuffer < duration){
        const decay = Math.max(0.6, 1 - p.decayRate * cycle);
        // ã‚µã‚¤ã‚¯ãƒ«ã”ã¨ã®å¼·åº¦ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆÂ±10%ï¼‰
        const cycleScale = 0.90 + 0.20 * rnd();
        // ãƒãƒ¼ã‚¹ãƒˆå†…ã®ãƒ‘ãƒ«ã‚¹æ•°
        const nPulses = Math.max(1, Math.floor(rBetween(p.pulsesPerBurstRange[0], p.pulsesPerBurstRange[1] + 1)));
        for (let i=0;i<nPulses;i++){
          const isLastPulse = (pulseCount + i + 1) >= targetPulseCount; // ã“ã‚Œã§å…¨ä½“ã®æœ€å¾Œã®ãƒ‘ãƒ«ã‚¹ã‚’æ¤œå‡º
          const peakAmp = rBetween(p.peakRange[0], p.peakRange[1]) * decay;
          // ãƒ‘ãƒ«ã‚¹è¿½åŠ ï¼ˆé‹­ã„â†’çŸ­ã„â†’å³æ¸›è¡°ï¼‰
          const tEnd = addPulseAt(t, peakAmp, cycleScale, isLastPulse);
          // ã‚¬ã‚¦ã‚¹åˆ†å¸ƒã§ãƒ‘ãƒ«ã‚¹é–“éš”ã‚’ç”Ÿæˆ
          const pulseInterval = gaussianRange(
            (p.pulseIntervalRange[0] + p.pulseIntervalRange[1]) / 2, // å¹³å‡
            p.pulseIntervalStdDev,                                    // æ¨™æº–åå·®
            p.pulseIntervalRange[0],                                  // æœ€å°å€¤
            p.pulseIntervalRange[1],                                  // æœ€å¤§å€¤
            rnd
          );
          t = tEnd + ms(pulseInterval) + jitter();
          if (t + settleBuffer >= duration) break;
          pulseCount++;
        }
        // æ¬¡ã®å¡Šã¾ã§ï¼ˆã‚¬ã‚¦ã‚¹åˆ†å¸ƒã§ãƒãƒ¼ã‚¹ãƒˆé–“éš”ã‚’ç”Ÿæˆï¼‰
        const burstInterval = gaussianRange(
          (p.burstIntervalRange[0] + p.burstIntervalRange[1]) / 2, // å¹³å‡
          p.burstIntervalStdDev,                                    // æ¨™æº–åå·®
          p.burstIntervalRange[0],                                  // æœ€å°å€¤
          p.burstIntervalRange[1],                                  // æœ€å¤§å€¤
          rnd
        );
        t += ms(burstInterval) + jitter() + maybeRareLongTame();
        cycle++;
      }

      // æœ€çµ‚çŠ¶æ…‹ã«å…¥ã‚‹ç›´å‰ã§æš—è»¢ã—ã¦ã„ã‚‹å ´åˆãŒã‚ã‚‹ãŸã‚ã€ç›´å‰KFã‚’æŒã¡ä¸Šã’
      if (keyframesGen.length > 0) {
        const lastIdx = keyframesGen.length - 1;
        const lastKF = keyframesGen[lastIdx];
        const isDark = lastKF.points && lastKF.points.some(p=> (p?.y ?? 0) < 0.95);
        if (isDark) {
          lastKF.points = controlPoints.map(cp=>({ id: cp.id, y: 1.0 }));
        }
      }

      // æœ€çµ‚çŠ¶æ…‹ï¼ˆå®‰å®šå¾Œ0.5ç§’ï¼‰
      const finalDuration = t + p.stableTimeAfterSettle;
      keyframesGen.push({ t: finalDuration, points: controlPoints.map(cp=>({ id: cp.id, y: 1.0 })) });
      
      return { version, duration: finalDuration, controlPoints, keyframes: keyframesGen };
    }

    // ç”Ÿæˆâ†’èª­ã¿è¾¼ã¿ ãƒœã‚¿ãƒ³
    genBtn && genBtn.addEventListener('click', ()=>{
      // ã‚µãƒ³ãƒ—ãƒ«ã«è¿‘ã„åˆ¶å¾¡ç‚¹é…ç½®ï¼ˆxã¯å·¦åŠåˆ† 0..0.5ï¼‰
      const cps = [
        { id: 101, x: 0.02 },
        { id: 102, x: 0.10 },
        { id: 103, x: 0.20 },
        { id: 104, x: 0.50 },
      ];
      const seed = (Date.now() & 0xffffffff) >>> 0;
      const timelineGen = generateFluorescentTimeline({
        duration: duration,
        controlPoints: cps,
        seed
      });

      // å†…éƒ¨å½¢å¼ï¼ˆsetKeyframesFromSpecï¼‰ã¸å¤‰æ›ã—ã¦åæ˜ 
      const spec = timelineGen.keyframes.map(kf=>{
        const map = new Map(kf.points.map(p=>[p.id, p.y]));
        const pts = cps.map(cp=>({ id: cp.id, x: cp.x, y: clamp01(map.get(cp.id) ?? 0) }));
        return { t: kf.t, pts };
      });
      setKeyframesFromSpec(spec, timelineGen.duration);
      // å†ç”Ÿé–‹å§‹ï¼ˆä»»æ„ï¼‰
      setPlaying(true);
    });

    function importJSONFile(file){
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          if (!data || !Array.isArray(data.keyframes)) throw new Error("invalid format: keyframes missing");
          const D = typeof data.duration === "number" ? data.duration : duration;

          // Strict schema with controlPoints
          const hasCP = Array.isArray(data.controlPoints);
          if (hasCP){
            // Validate controlPoints
            const cps = data.controlPoints.map(cp=>{
              const id = Number(cp.id);
              const xv = Number(cp.x);
              if (!Number.isFinite(id)) throw new Error("controlPoints: id must be a number");
              if (!Number.isFinite(xv)) throw new Error("controlPoints: x must be a number");
              const x = clamp(xv, 0, 0.5);
              return { id, x };
            });
            if (cps.length === 0) throw new Error("controlPoints must not be empty");
            // Unique ids
            const idSet = new Set();
            for (const cp of cps){
              if (idSet.has(cp.id)) throw new Error("duplicate controlPoint id: "+cp.id);
              idSet.add(cp.id);
            }
            // sort by x (stable)
            cps.sort((a,b)=> (a.x===b.x? a.id-b.id : a.x-b.x));

            // Validate each keyframe has exactly the same ids
            const idList = cps.map(cp=>cp.id);
            const spec = data.keyframes.map(entry=>{
              const t = clamp(+entry.t || 0, 0, D);
              const ptsRaw = Array.isArray(entry.points) ? entry.points : [];
              if (ptsRaw.length !== idList.length) throw new Error(`keyframe @t=${t}: points length mismatch`);
              const map = new Map(ptsRaw.map(p=>[+p.id||0, clamp(+p.y||0, 0, 1)]));
              // check all ids exist and no extras
              for (const id of idList){ if (!map.has(id)) throw new Error(`keyframe @t=${t}: missing id ${id}`); }
              if (map.size !== idList.length) throw new Error(`keyframe @t=${t}: contains unknown ids`);
              // build full points with x from controlPoints
              const pts = cps.map(cp=>({ id: cp.id, x: cp.x, y: map.get(cp.id) }));
              return { t, pts };
            });
            setKeyframesFromSpec(spec, D);
          } else {
            // Backward compatibility (legacy schema): validate consistent ids across frames
            const frames = data.keyframes;
            if (!Array.isArray(frames) || frames.length === 0) throw new Error("no keyframes");
            const firstPts = (frames[0].points||[]).map(p=>+p.id||0);
            const idSet0 = new Set(firstPts);
            const spec = frames.map(entry=>{
              const t = clamp(+entry.t || 0, 0, D);
              const ptsRaw = Array.isArray(entry.points) ? entry.points : [];
              const ids = ptsRaw.map(p=>+p.id||0);
              const idSetKF = new Set(ids);
              if (idSetKF.size !== idSet0.size) throw new Error(`keyframe @t=${t}: inconsistent point count`);
              for (const id of idSet0){ if (!idSetKF.has(id)) throw new Error(`keyframe @t=${t}: missing id ${id}`); }
              const pts = ptsRaw.map(p=>({ id:+p.id||0, x: clamp(+p.x||0,0,0.5), y: clamp(+p.y||0,0,1) }));
              return { t, pts: pts.length ? pts : shapeOff() };
            });
            setKeyframesFromSpec(spec, D);
          }
        } catch (err){
          alert("JSONã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: " + err.message);
        }
      };
      reader.readAsText(file);
    }

    // ===== Drag & Drop JSON loader =====
    window.addEventListener('dragover', (e)=>{ e.preventDefault(); });
    window.addEventListener('drop', (e)=>{
      e.preventDefault();
      const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
      if (file && /\.json$/i.test(file.name)){
        importJSONFile(file);
      }
    });



    // Hook up buttons
    window.addEventListener('DOMContentLoaded', ()=>{});

    // ===== Initial =====
    function renderAll(){
      const cssW = getCssWidth();
      renderBar(cssW); renderAxis(cssW);
      renderLamp(cssW); renderLampAxis(cssW);
      renderCurve(cssW); renderTimeline(cssW);
    }

    (function init(){
      duration = Number(durationInput.value) || 2.0;
      loopPlay = !!loopChk.checked;
      initDefaultKeyframes();
      renderAll();
      syncTimeUI();
    })();
</script>
</body>
</html>
